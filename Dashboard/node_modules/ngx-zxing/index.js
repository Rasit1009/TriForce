import { Component, EventEmitter, Input, NgModule, Output, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject as Subject$1 } from 'rxjs/Subject';

var Exception = (function () {
    /**
     * @param {?} type
     * @param {?=} message
     */
    function Exception(type, message) {
        this.type = type;
        this.message = message;
    }
    /**
     * @return {?}
     */
    Exception.prototype.getType = function () {
        return this.type;
    };
    /**
     * @return {?}
     */
    Exception.prototype.getMessage = function () {
        return this.message;
    };
    /**
     * @param {?} ex
     * @param {?} type
     * @return {?}
     */
    Exception.isOfType = function (ex, type) {
        return ex.type === type;
    };
    return Exception;
}());
Exception.IllegalArgumentException = "IllegalArgumentException";
Exception.NotFoundException = "NotFoundException";
Exception.ArithmeticException = "ArithmeticException";
Exception.FormatException = "FormatException";
Exception.ChecksumException = "ChecksumException";
Exception.WriterException = "WriterException";
Exception.IllegalStateException = "IllegalStateException";
Exception.UnsupportedOperationException = "UnsupportedOperationException";
Exception.ReedSolomonException = "ReedSolomonException";
Exception.ArgumentException = "ArgumentException";
Exception.ReaderException = "ReaderException";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class is the core bitmap class used by ZXing to represent 1 bit data. Reader objects
 * accept a BinaryBitmap and attempt to decode it.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
/*namespace com.google.zxing {*/
var BinaryBitmap = (function () {
    /**
     * @param {?} binarizer
     */
    function BinaryBitmap(binarizer) {
        this.binarizer = binarizer;
        if (binarizer === null) {
            throw new Exception(Exception.IllegalArgumentException, "Binarizer must be non-null.");
        }
    }
    /**
     * @return {?} The width of the bitmap.
     */
    BinaryBitmap.prototype.getWidth = function () {
        return this.binarizer.getWidth();
    };
    /**
     * @return {?} The height of the bitmap.
     */
    BinaryBitmap.prototype.getHeight = function () {
        return this.binarizer.getHeight();
    };
    /**
     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
    cached data. Callers should assume this method is expensive and call it as seldom as possible.
    This method is intended for decoding 1D barcodes and may choose to apply sharpening.
    
    \@param y The row to fetch, which must be in [0, bitmap height)
    \@param row An optional preallocated array. If null or too small, it will be ignored.
               If used, the Binarizer will call BitArray.clear(). Always use the returned object.
    \@return The array of bits for this row (true means black).
    \@throws NotFoundException if row can't be binarized
     * @param {?} y
     * @param {?} row
     * @return {?}
     */
    BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {
        return this.binarizer.getBlackRow(y, row);
    };
    /**
     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
    and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
    may not apply sharpening. Therefore, a row from this matrix may not be identical to one
    fetched using getBlackRow(), so don't mix and match between them.
    
    \@return The 2D array of bits for the image (true means black).
    \@throws NotFoundException if image can't be binarized to make a matrix
     * @return {?}
     */
    BinaryBitmap.prototype.getBlackMatrix = function () {
        // The matrix is created on demand the first time it is requested, then cached. There are two
        // reasons for this:
        // 1. This work will never be done if the caller only installs 1D Reader objects, or if a
        //    1D Reader finds a barcode before the 2D Readers run.
        // 2. This work will only be done once even if the caller installs multiple 2D Readers.
        if (this.matrix === null || this.matrix === undefined) {
            this.matrix = this.binarizer.getBlackMatrix();
        }
        return this.matrix;
    };
    /**
     * @return {?} Whether this bitmap can be cropped.
     */
    BinaryBitmap.prototype.isCropSupported = function () {
        return this.binarizer.getLuminanceSource().isCropSupported();
    };
    /**
     * Returns a new object with cropped image data. Implementations may keep a reference to the
    original data rather than a copy. Only callable if isCropSupported() is true.
    
    \@param left The left coordinate, which must be in [0,getWidth())
    \@param top The top coordinate, which must be in [0,getHeight())
    \@param width The width of the rectangle to crop.
    \@param height The height of the rectangle to crop.
    \@return A cropped version of this object.
     * @param {?} left
     * @param {?} top
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        var /** @type {?} */ newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
    };
    /**
     * @return {?} Whether this bitmap supports counter-clockwise rotation.
     */
    BinaryBitmap.prototype.isRotateSupported = function () {
        return this.binarizer.getLuminanceSource().isRotateSupported();
    };
    /**
     * Returns a new object with rotated image data by 90 degrees counterclockwise.
    Only callable if {\@link #isRotateSupported()} is true.
    
    \@return A rotated version of this object.
     * @return {?}
     */
    BinaryBitmap.prototype.rotateCounterClockwise = function () {
        var /** @type {?} */ newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
    };
    /**
     * Returns a new object with rotated image data by 45 degrees counterclockwise.
    Only callable if {\@link #isRotateSupported()} is true.
    
    \@return A rotated version of this object.
     * @return {?}
     */
    BinaryBitmap.prototype.rotateCounterClockwise45 = function () {
        var /** @type {?} */ newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
    };
    /**
     * @return {?}
     */
    BinaryBitmap.prototype.toString = function () {
        try {
            return this.getBlackMatrix().toString();
        }
        catch (e /*: NotFoundException*/) {
            return "";
        }
    };
    return BinaryBitmap;
}());

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.
It allows the algorithm to vary polymorphically, for example allowing a very expensive
thresholding technique for servers and a fast one for mobile. It also permits the implementation
to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.

\@author dswitkin\@google.com (Daniel Switkin)
 * @abstract
 */
var Binarizer = (function () {
    /**
     * @param {?} source
     */
    function Binarizer(source) {
        this.source = source;
    }
    /**
     * @return {?}
     */
    Binarizer.prototype.getLuminanceSource = function () {
        return this.source;
    };
    /**
     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
    cached data. Callers should assume this method is expensive and call it as seldom as possible.
    This method is intended for decoding 1D barcodes and may choose to apply sharpening.
    For callers which only examine one row of pixels at a time, the same BitArray should be reused
    and passed in with each call for performance. However it is legal to keep more than one row
    at a time if needed.
    
    \@param y The row to fetch, which must be in [0, bitmap height)
    \@param row An optional preallocated array. If null or too small, it will be ignored.
               If used, the Binarizer will call BitArray.clear(). Always use the returned object.
    \@return The array of bits for this row (true means black).
    \@throws NotFoundException if row can't be binarized
     * @abstract
     * @param {?} y
     * @param {?} row
     * @return {?}
     */
    Binarizer.prototype.getBlackRow = function (y /*iny*/, row) { };
    /**
     * Converts a 2D array of luminance data to 1 bit data. As above, assume this method is expensive
    and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
    may not apply sharpening. Therefore, a row from this matrix may not be identical to one
    fetched using getBlackRow(), so don't mix and match between them.
    
    \@return The 2D array of bits for the image (true means black).
    \@throws NotFoundException if image can't be binarized to make a matrix
     * @abstract
     * @return {?}
     */
    Binarizer.prototype.getBlackMatrix = function () { };
    /**
     * Creates a new object with the same type as this Binarizer implementation, but with pristine
    state. This is needed because Binarizer implementations may be stateful, e.g. keeping a cache
    of 1 bit data. See Effective Java for why we can't use Java's clone() method.
    
    \@param source The LuminanceSource this Binarizer will operate on.
    \@return A new concrete Binarizer implementation object.
     * @abstract
     * @param {?} source
     * @return {?}
     */
    Binarizer.prototype.createBinarizer = function (source) { };
    /**
     * @return {?}
     */
    Binarizer.prototype.getWidth = function () {
        return this.source.getWidth();
    };
    /**
     * @return {?}
     */
    Binarizer.prototype.getHeight = function () {
        return this.source.getHeight();
    };
    return Binarizer;
}());

var System = (function () {
    function System() {
    }
    /**
     * @param {?} src
     * @param {?} srcPos
     * @param {?} dest
     * @param {?} destPos
     * @param {?} length
     * @return {?}
     */
    System.arraycopy = function (src, srcPos, dest, destPos, length) {
        // TODO: better use split or set?
        var /** @type {?} */ i = srcPos;
        var /** @type {?} */ j = destPos;
        var /** @type {?} */ c = length;
        while (c--) {
            dest[j++] = src[i++];
        }
    };
    /**
     * @return {?}
     */
    System.currentTimeMillis = function () {
        return Date.now();
    };
    return System;
}());

var Integer = (function () {
    function Integer() {
    }
    /**
     * @param {?} i
     * @return {?}
     */
    Integer.numberOfTrailingZeros = function (i) {
        var /** @type {?} */ y;
        if (i === 0)
            return 32;
        var /** @type {?} */ n = 31;
        y = i << 16;
        if (y !== 0) {
            n -= 16;
            i = y;
        }
        y = i << 8;
        if (y !== 0) {
            n -= 8;
            i = y;
        }
        y = i << 4;
        if (y !== 0) {
            n -= 4;
            i = y;
        }
        y = i << 2;
        if (y !== 0) {
            n -= 2;
            i = y;
        }
        return n - ((i << 1) >>> 31);
    };
    /**
     * @param {?} i
     * @return {?}
     */
    Integer.numberOfLeadingZeros = function (i) {
        // HD, Figure 5-6
        if (i === 0) {
            return 32;
        }
        var /** @type {?} */ n = 1;
        if (i >>> 16 === 0) {
            n += 16;
            i <<= 16;
        }
        if (i >>> 24 === 0) {
            n += 8;
            i <<= 8;
        }
        if (i >>> 28 === 0) {
            n += 4;
            i <<= 4;
        }
        if (i >>> 30 === 0) {
            n += 2;
            i <<= 2;
        }
        n -= i >>> 31;
        return n;
    };
    /**
     * @param {?} i
     * @return {?}
     */
    Integer.toHexString = function (i) {
        return i.toString(16);
    };
    /**
     * @param {?} i
     * @return {?}
     */
    Integer.bitCount = function (i) {
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    };
    return Integer;
}());
Integer.MIN_VALUE_32_BITS = -2147483648;

var Arrays = (function () {
    function Arrays() {
    }
    /**
     * @param {?} first
     * @param {?} second
     * @return {?}
     */
    Arrays.equals = function (first, second) {
        if (!first) {
            return false;
        }
        if (!second) {
            return false;
        }
        if (!first.length) {
            return false;
        }
        if (!second.length) {
            return false;
        }
        if (first.length !== second.length) {
            return false;
        }
        for (var /** @type {?} */ i = 0, /** @type {?} */ length_1 = first.length; i < length_1; i++) {
            if (first[i] !== second[i]) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {?} a
     * @return {?}
     */
    Arrays.hashCode = function (a) {
        if (a === null) {
            return 0;
        }
        var /** @type {?} */ result = 1;
        for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
            var element = a_1[_i];
            result = 31 * result + element;
        }
        return result;
    };
    /**
     * @param {?} a
     * @param {?} value
     * @return {?}
     */
    Arrays.fillUint8Array = function (a, value) {
        for (var /** @type {?} */ i = 0; i != a.length; i++) {
            a[i] = value;
        }
    };
    return Arrays;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.common {*/
/*import java.util.Arrays;*/
/**
 * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>

\@author Sean Owen
 */
var BitArray /*implements Cloneable*/ = (function () {
    /**
     * @param {?=} size
     * @param {?=} bits
     */
    function BitArray(size /*int*/, bits) {
        if (undefined === size) {
            this.size = 0;
            this.bits = new Int32Array(1);
        }
        else {
            this.size = size;
            if (undefined === bits || null === bits) {
                this.bits = BitArray.makeArray(size);
            }
            else {
                this.bits = bits;
            }
        }
    }
    /**
     * @return {?}
     */
    BitArray.prototype.getSize = function () {
        return this.size;
    };
    /**
     * @return {?}
     */
    BitArray.prototype.getSizeInBytes = function () {
        return Math.floor((this.size + 7) / 8);
    };
    /**
     * @param {?} size
     * @return {?}
     */
    BitArray.prototype.ensureCapacity = function (size /*int*/) {
        if (size > this.bits.length * 32) {
            var /** @type {?} */ newBits = BitArray.makeArray(size);
            System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
            this.bits = newBits;
        }
    };
    /**
     * @param {?} i bit to get
     * @return {?}
     */
    BitArray.prototype.get = function (i /*int*/) {
        return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;
    };
    /**
     * Sets bit i.
    
    \@param i bit to set
     * @param {?} i
     * @return {?}
     */
    BitArray.prototype.set = function (i /*int*/) {
        this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);
    };
    /**
     * Flips bit i.
    
    \@param i bit to set
     * @param {?} i
     * @return {?}
     */
    BitArray.prototype.flip = function (i /*int*/) {
        this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);
    };
    /**
     * @param {?} from first bit to check
     * @return {?}
     */
    BitArray.prototype.getNextSet = function (from /*int*/) {
        var /** @type {?} */ size = this.size;
        if (from >= size) {
            return size;
        }
        var /** @type {?} */ bits = this.bits;
        var /** @type {?} */ bitsOffset = Math.floor(from / 32);
        var /** @type {?} */ currentBits = bits[bitsOffset];
        // mask off lesser bits first
        currentBits &= ~((1 << (from & 0x1F)) - 1);
        var /** @type {?} */ length = bits.length;
        while (currentBits === 0) {
            if (++bitsOffset === length) {
                return size;
            }
            currentBits = bits[bitsOffset];
        }
        var /** @type {?} */ result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);
        return result > size ? size : result;
    };
    /**
     * @param {?} from index to start looking for unset bit
     * @return {?}
     */
    BitArray.prototype.getNextUnset = function (from /*int*/) {
        var /** @type {?} */ size = this.size;
        if (from >= size) {
            return size;
        }
        var /** @type {?} */ bits = this.bits;
        var /** @type {?} */ bitsOffset = Math.floor(from / 32);
        var /** @type {?} */ currentBits = ~bits[bitsOffset];
        // mask off lesser bits first
        currentBits &= ~((1 << (from & 0x1F)) - 1);
        var /** @type {?} */ length = bits.length;
        while (currentBits === 0) {
            if (++bitsOffset === length) {
                return size;
            }
            currentBits = ~bits[bitsOffset];
        }
        var /** @type {?} */ result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);
        return result > size ? size : result;
    };
    /**
     * Sets a block of 32 bits, starting at bit i.
    
    \@param i first bit to set
    \@param newBits the new value of the next 32 bits. Note again that the least-significant bit
    corresponds to bit i, the next-least-significant to i+1, and so on.
     * @param {?} i
     * @param {?} newBits
     * @return {?}
     */
    BitArray.prototype.setBulk = function (i /*int*/, newBits /*int*/) {
        this.bits[Math.floor(i / 32)] = newBits;
    };
    /**
     * Sets a range of bits.
    
    \@param start start of range, inclusive.
    \@param end end of range, exclusive
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    BitArray.prototype.setRange = function (start /*int*/, end /*int*/) {
        if (end < start || start < 0 || end > this.size) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        if (end === start) {
            return;
        }
        end--; // will be easier to treat this as the last actually set bit -- inclusive
        var /** @type {?} */ firstInt = Math.floor(start / 32);
        var /** @type {?} */ lastInt = Math.floor(end / 32);
        var /** @type {?} */ bits = this.bits;
        for (var /** @type {?} */ i = firstInt; i <= lastInt; i++) {
            var /** @type {?} */ firstBit = i > firstInt ? 0 : start & 0x1F;
            var /** @type {?} */ lastBit = i < lastInt ? 31 : end & 0x1F;
            // Ones from firstBit to lastBit, inclusive
            var /** @type {?} */ mask = (2 << lastBit) - (1 << firstBit);
            bits[i] |= mask;
        }
    };
    /**
     * Clears all bits (sets to false).
     * @return {?}
     */
    BitArray.prototype.clear = function () {
        var /** @type {?} */ max = this.bits.length;
        var /** @type {?} */ bits = this.bits;
        for (var /** @type {?} */ i = 0; i < max; i++) {
            bits[i] = 0;
        }
    };
    /**
     * Efficient method to check if a range of bits is set, or not set.
    
    \@param start start of range, inclusive.
    \@param end end of range, exclusive
    \@param value if true, checks that bits in range are set, otherwise checks that they are not set
    \@return true iff all bits are set or not set in range, according to value argument
    \@throws IllegalArgumentException if end is less than start or the range is not contained in the array
     * @param {?} start
     * @param {?} end
     * @param {?} value
     * @return {?}
     */
    BitArray.prototype.isRange = function (start /*int*/, end /*int*/, value) {
        if (end < start || start < 0 || end > this.size) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        if (end === start) {
            return true; // empty range matches
        }
        end--; // will be easier to treat this as the last actually set bit -- inclusive
        var /** @type {?} */ firstInt = Math.floor(start / 32);
        var /** @type {?} */ lastInt = Math.floor(end / 32);
        var /** @type {?} */ bits = this.bits;
        for (var /** @type {?} */ i = firstInt; i <= lastInt; i++) {
            var /** @type {?} */ firstBit = i > firstInt ? 0 : start & 0x1F;
            var /** @type {?} */ lastBit = i < lastInt ? 31 : end & 0x1F;
            // Ones from firstBit to lastBit, inclusive
            var /** @type {?} */ mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;
            // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits
            // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,
            // equals the mask, or we're looking for 0s and the masked portion is not all 0s
            if ((bits[i] & mask) !== (value ? mask : 0)) {
                return false;
            }
        }
        return true;
    };
    /**
     * @param {?} bit
     * @return {?}
     */
    BitArray.prototype.appendBit = function (bit) {
        this.ensureCapacity(this.size + 1);
        if (bit) {
            this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);
        }
        this.size++;
    };
    /**
     * Appends the least-significant bits, from value, in order from most-significant to
    least-significant. For example, appending 6 bits from 0x000001E will append the bits
    0, 1, 1, 1, 1, 0 in that order.
    
    \@param value {\@code int} containing bits to append
    \@param numBits bits from value to append
     * @param {?} value
     * @param {?} numBits
     * @return {?}
     */
    BitArray.prototype.appendBits = function (value /*int*/, numBits /*int*/) {
        if (numBits < 0 || numBits > 32) {
            throw new Exception(Exception.IllegalArgumentException, "Num bits must be between 0 and 32");
        }
        this.ensureCapacity(this.size + numBits);
        for (var /** @type {?} */ numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
            this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) == 1);
        }
    };
    /**
     * @param {?} other
     * @return {?}
     */
    BitArray.prototype.appendBitArray = function (other) {
        var /** @type {?} */ otherSize = other.size;
        this.ensureCapacity(this.size + otherSize);
        for (var /** @type {?} */ i = 0; i < otherSize; i++) {
            this.appendBit(other.get(i));
        }
    };
    /**
     * @param {?} other
     * @return {?}
     */
    BitArray.prototype.xor = function (other) {
        if (this.size != other.size) {
            throw new Exception(Exception.IllegalArgumentException, "Sizes don't match");
        }
        var /** @type {?} */ bits = this.bits;
        for (var /** @type {?} */ i = 0, /** @type {?} */ length_1 = bits.length; i < length_1; i++) {
            // The last int could be incomplete (i.e. not have 32 bits in
            // it) but there is no problem since 0 XOR 0 == 0.
            bits[i] ^= other.bits[i];
        }
    };
    /**
     *
    \@param bitOffset first bit to start writing
    \@param array array to write into. Bytes are written most-significant byte first. This is the opposite
     of the internal representation, which is exposed by {\@link #getBitArray()}
    \@param offset position in array to start writing
    \@param numBytes how many bytes to write
     * @param {?} bitOffset
     * @param {?} array
     * @param {?} offset
     * @param {?} numBytes
     * @return {?}
     */
    BitArray.prototype.toBytes = function (bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {
        for (var /** @type {?} */ i = 0; i < numBytes; i++) {
            var /** @type {?} */ theByte = 0;
            for (var /** @type {?} */ j = 0; j < 8; j++) {
                if (this.get(bitOffset)) {
                    theByte |= 1 << (7 - j);
                }
                bitOffset++;
            }
            array[offset + i] = theByte;
        }
    };
    /**
     * @return {?} underlying array of ints. The first element holds the first 32 bits, and the least
     */
    BitArray.prototype.getBitArray = function () {
        return this.bits;
    };
    /**
     * Reverses all bits in the array.
     * @return {?}
     */
    BitArray.prototype.reverse = function () {
        var /** @type {?} */ newBits = new Int32Array(this.bits.length);
        // reverse all int's first
        var /** @type {?} */ len = Math.floor((this.size - 1) / 32);
        var /** @type {?} */ oldBitsLen = len + 1;
        var /** @type {?} */ bits = this.bits;
        for (var /** @type {?} */ i = 0; i < oldBitsLen; i++) {
            var /** @type {?} */ x = bits[i];
            x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
            x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
            x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);
            x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);
            x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);
            newBits[len - i] = x;
        }
        // now correct the int's if the bit size isn't a multiple of 32
        if (this.size !== oldBitsLen * 32) {
            var /** @type {?} */ leftOffset = oldBitsLen * 32 - this.size;
            var /** @type {?} */ currentInt = newBits[0] >>> leftOffset;
            for (var /** @type {?} */ i = 1; i < oldBitsLen; i++) {
                var /** @type {?} */ nextInt = newBits[i];
                currentInt |= nextInt << (32 - leftOffset);
                newBits[i - 1] = currentInt;
                currentInt = nextInt >>> leftOffset;
            }
            newBits[oldBitsLen - 1] = currentInt;
        }
        this.bits = newBits;
    };
    /**
     * @param {?} size
     * @return {?}
     */
    BitArray.makeArray = function (size /*int*/) {
        return new Int32Array(Math.floor((size + 31) / 32));
    };
    /**
     * @param {?} o
     * @return {?}
     */
    BitArray.prototype.equals = function (o) {
        if (!(o instanceof BitArray)) {
            return false;
        }
        var /** @type {?} */ other = (o);
        return this.size === other.size && Arrays.equals(this.bits, other.bits);
    };
    /**
     * @return {?}
     */
    BitArray.prototype.hashCode = function () {
        return 31 * this.size + Arrays.hashCode(this.bits);
    };
    /**
     * @return {?}
     */
    BitArray.prototype.toString = function () {
        var /** @type {?} */ result = "";
        for (var /** @type {?} */ i = 0, /** @type {?} */ size = this.size; i < size; i++) {
            if ((i & 0x07) === 0) {
                result += " ";
            }
            result += this.get(i) ? "X" : ".";
        }
        return result;
    };
    /**
     * @return {?}
     */
    BitArray.prototype.clone = function () {
        return new BitArray(this.size, this.bits.slice());
    };
    return BitArray;
}());

var StringBuilder = (function () {
    /**
     * @param {?=} value
     */
    function StringBuilder(value) {
        if (value === void 0) { value = ""; }
        this.value = value;
    }
    /**
     * @param {?} s
     * @return {?}
     */
    StringBuilder.prototype.append = function (s) {
        this.value += s;
        return this;
    };
    /**
     * @return {?}
     */
    StringBuilder.prototype.length = function () {
        return this.value.length;
    };
    /**
     * @param {?} n
     * @return {?}
     */
    StringBuilder.prototype.charAt = function (n) {
        return this.value.charAt(n);
    };
    /**
     * @param {?} n
     * @return {?}
     */
    StringBuilder.prototype.deleteCharAt = function (n) {
        this.value = this.value.substr(0, n) + this.value.substring(n + 1);
    };
    /**
     * @param {?} n
     * @param {?} c
     * @return {?}
     */
    StringBuilder.prototype.setCharAt = function (n, c) {
        this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);
    };
    /**
     * @return {?}
     */
    StringBuilder.prototype.toString = function () {
        return this.value;
    };
    return StringBuilder;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.common {*/
/*import java.util.Arrays;*/
/**
 * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common
module, x is the column position, and y is the row position. The ordering is always x, y.
The origin is at the top-left.</p>

<p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins
with a new int. This is done intentionally so that we can copy out a row into a BitArray very
efficiently.</p>

<p>The ordering of bits is row-major. Within each int, the least significant bits are used first,
meaning they represent lower x values. This is compatible with BitArray's implementation.</p>

\@author Sean Owen
\@author dswitkin\@google.com (Daniel Switkin)
 */
var BitMatrix /*implements Cloneable*/ = (function () {
    /**
     * @param {?} width
     * @param {?=} height
     * @param {?=} rowSize
     * @param {?=} bits
     */
    function BitMatrix(width /*int*/, height /*int*/, rowSize /*int*/, bits) {
        this.width = width; /*int*/
        this.height = height; /*int*/
        this.rowSize = rowSize; /*int*/
        this.bits = bits;
        if (undefined === height || null === height) {
            height = width;
        }
        this.height = height;
        if (width < 1 || height < 1) {
            throw new Exception(Exception.IllegalArgumentException, "Both dimensions must be greater than 0");
        }
        if (undefined === rowSize || null === rowSize) {
            rowSize = Math.floor((width + 31) / 32);
        }
        this.rowSize = rowSize;
        if (undefined === bits || null === bits) {
            this.bits = new Int32Array(this.rowSize * this.height);
        }
    }
    /**
     * Interprets a 2D array of booleans as a {\@link BitMatrix}, where "true" means an "on" bit.
    
    \@param image bits of the image, as a row-major 2D array. Elements are arrays representing rows
    \@return {\@link BitMatrix} representation of image
     * @param {?} image
     * @return {?}
     */
    BitMatrix.parseFromBooleanArray = function (image) {
        var /** @type {?} */ height = image.length;
        var /** @type {?} */ width = image[0].length;
        var /** @type {?} */ bits = new BitMatrix(width, height);
        for (var /** @type {?} */ i = 0; i < height; i++) {
            var /** @type {?} */ imageI = image[i];
            for (var /** @type {?} */ j = 0; j < width; j++) {
                if (imageI[j]) {
                    bits.set(j, i);
                }
            }
        }
        return bits;
    };
    /**
     * @param {?} stringRepresentation
     * @param {?} setString
     * @param {?} unsetString
     * @return {?}
     */
    BitMatrix.parseFromString = function (stringRepresentation, setString, unsetString) {
        if (stringRepresentation === null) {
            throw new Exception(Exception.IllegalArgumentException, "stringRepresentation cannot be null");
        }
        var /** @type {?} */ bits = new Array(stringRepresentation.length);
        var /** @type {?} */ bitsPos = 0;
        var /** @type {?} */ rowStartPos = 0;
        var /** @type {?} */ rowLength = -1;
        var /** @type {?} */ nRows = 0;
        var /** @type {?} */ pos = 0;
        while (pos < stringRepresentation.length) {
            if (stringRepresentation.charAt(pos) === '\n' ||
                stringRepresentation.charAt(pos) === '\r') {
                if (bitsPos > rowStartPos) {
                    if (rowLength === -1) {
                        rowLength = bitsPos - rowStartPos;
                    }
                    else if (bitsPos - rowStartPos != rowLength) {
                        throw new Exception(Exception.IllegalArgumentException, "row lengths do not match");
                    }
                    rowStartPos = bitsPos;
                    nRows++;
                }
                pos++;
            }
            else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
                pos += setString.length;
                bits[bitsPos] = true;
                bitsPos++;
            }
            else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
                pos += unsetString.length;
                bits[bitsPos] = false;
                bitsPos++;
            }
            else {
                throw new Exception(Exception.IllegalArgumentException, "illegal character encountered: " + stringRepresentation.substring(pos));
            }
        }
        // no EOL at end?
        if (bitsPos > rowStartPos) {
            if (rowLength === -1) {
                rowLength = bitsPos - rowStartPos;
            }
            else if (bitsPos - rowStartPos !== rowLength) {
                throw new Exception(Exception.IllegalArgumentException, "row lengths do not match");
            }
            nRows++;
        }
        var /** @type {?} */ matrix = new BitMatrix(rowLength, nRows);
        for (var /** @type {?} */ i = 0; i < bitsPos; i++) {
            if (bits[i]) {
                matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));
            }
        }
        return matrix;
    };
    /**
     * <p>Gets the requested bit, where true means black.</p>
    
    \@param x The horizontal component (i.e. which column)
    \@param y The vertical component (i.e. which row)
    \@return value of given bit in matrix
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    BitMatrix.prototype.get = function (x /*int*/, y /*int*/) {
        var /** @type {?} */ offset = y * this.rowSize + Math.floor(x / 32);
        return ((this.bits[offset] >>> (x & 0x1f)) & 1) != 0;
    };
    /**
     * <p>Sets the given bit to true.</p>
    
    \@param x The horizontal component (i.e. which column)
    \@param y The vertical component (i.e. which row)
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    BitMatrix.prototype.set = function (x /*int*/, y /*int*/) {
        var /** @type {?} */ offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;
    };
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    BitMatrix.prototype.unset = function (x /*int*/, y /*int*/) {
        var /** @type {?} */ offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);
    };
    /**
     * <p>Flips the given bit.</p>
    
    \@param x The horizontal component (i.e. which column)
    \@param y The vertical component (i.e. which row)
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    BitMatrix.prototype.flip = function (x /*int*/, y /*int*/) {
        var /** @type {?} */ offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);
    };
    /**
     * Exclusive-or (XOR): Flip the bit in this {\@code BitMatrix} if the corresponding
    mask bit is set.
    
    \@param mask XOR mask
     * @param {?} mask
     * @return {?}
     */
    BitMatrix.prototype.xor = function (mask) {
        if (this.width != mask.getWidth() || this.height != mask.getHeight()
            || this.rowSize != mask.getRowSize()) {
            throw new Exception(Exception.IllegalArgumentException, "input matrix dimensions do not match");
        }
        var /** @type {?} */ rowArray = new BitArray(Math.floor(this.width / 32) + 1);
        var /** @type {?} */ rowSize = this.rowSize;
        var /** @type {?} */ bits = this.bits;
        for (var /** @type {?} */ y = 0, /** @type {?} */ height = this.height; y < height; y++) {
            var /** @type {?} */ offset = y * rowSize;
            var /** @type {?} */ row = mask.getRow(y, rowArray).getBitArray();
            for (var /** @type {?} */ x = 0; x < rowSize; x++) {
                bits[offset + x] ^= row[x];
            }
        }
    };
    /**
     * Clears all bits (sets to false).
     * @return {?}
     */
    BitMatrix.prototype.clear = function () {
        var /** @type {?} */ bits = this.bits;
        var /** @type {?} */ max = bits.length;
        for (var /** @type {?} */ i = 0; i < max; i++) {
            bits[i] = 0;
        }
    };
    /**
     * <p>Sets a square region of the bit matrix to true.</p>
    
    \@param left The horizontal position to begin at (inclusive)
    \@param top The vertical position to begin at (inclusive)
    \@param width The width of the region
    \@param height The height of the region
     * @param {?} left
     * @param {?} top
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    BitMatrix.prototype.setRegion = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        if (top < 0 || left < 0) {
            throw new Exception(Exception.IllegalArgumentException, "Left and top must be nonnegative");
        }
        if (height < 1 || width < 1) {
            throw new Exception(Exception.IllegalArgumentException, "Height and width must be at least 1");
        }
        var /** @type {?} */ right = left + width;
        var /** @type {?} */ bottom = top + height;
        if (bottom > this.height || right > this.width) {
            throw new Exception(Exception.IllegalArgumentException, "The region must fit inside the matrix");
        }
        var /** @type {?} */ rowSize = this.rowSize;
        var /** @type {?} */ bits = this.bits;
        for (var /** @type {?} */ y = top; y < bottom; y++) {
            var /** @type {?} */ offset = y * rowSize;
            for (var /** @type {?} */ x = left; x < right; x++) {
                bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);
            }
        }
    };
    /**
     * A fast method to retrieve one row of data from the matrix as a BitArray.
    
    \@param y The row to retrieve
    \@param row An optional caller-allocated BitArray, will be allocated if null or too small
    \@return The resulting BitArray - this reference should always be used even when passing
            your own row
     * @param {?} y
     * @param {?=} row
     * @return {?}
     */
    BitMatrix.prototype.getRow = function (y /*int*/, row) {
        if (row === null || row === undefined || row.getSize() < this.width) {
            row = new BitArray(this.width);
        }
        else {
            row.clear();
        }
        var /** @type {?} */ rowSize = this.rowSize;
        var /** @type {?} */ bits = this.bits;
        var /** @type {?} */ offset = y * rowSize;
        for (var /** @type {?} */ x = 0; x < rowSize; x++) {
            row.setBulk(x * 32, bits[offset + x]);
        }
        return row;
    };
    /**
     * @param {?} y row to set
     * @param {?} row
     * @return {?}
     */
    BitMatrix.prototype.setRow = function (y /*int*/, row) {
        System.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
    };
    /**
     * Modifies this {\@code BitMatrix} to represent the same but rotated 180 degrees
     * @return {?}
     */
    BitMatrix.prototype.rotate180 = function () {
        var /** @type {?} */ width = this.getWidth();
        var /** @type {?} */ height = this.getHeight();
        var /** @type {?} */ topRow = new BitArray(width);
        var /** @type {?} */ bottomRow = new BitArray(width);
        for (var /** @type {?} */ i = 0, /** @type {?} */ length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {
            topRow = this.getRow(i, topRow);
            bottomRow = this.getRow(height - 1 - i, bottomRow);
            topRow.reverse();
            bottomRow.reverse();
            this.setRow(i, bottomRow);
            this.setRow(height - 1 - i, topRow);
        }
    };
    /**
     * This is useful in detecting the enclosing rectangle of a 'pure' barcode.
    
    \@return {\@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white
     * @return {?}
     */
    BitMatrix.prototype.getEnclosingRectangle = function () {
        var /** @type {?} */ width = this.width;
        var /** @type {?} */ height = this.height;
        var /** @type {?} */ rowSize = this.rowSize;
        var /** @type {?} */ bits = this.bits;
        var /** @type {?} */ left = width;
        var /** @type {?} */ top = height;
        var /** @type {?} */ right = -1;
        var /** @type {?} */ bottom = -1;
        for (var /** @type {?} */ y = 0; y < height; y++) {
            for (var /** @type {?} */ x32 = 0; x32 < rowSize; x32++) {
                var /** @type {?} */ theBits = bits[y * rowSize + x32];
                if (theBits !== 0) {
                    if (y < top) {
                        top = y;
                    }
                    if (y > bottom) {
                        bottom = y;
                    }
                    if (x32 * 32 < left) {
                        var /** @type {?} */ bit = 0;
                        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {
                            bit++;
                        }
                        if ((x32 * 32 + bit) < left) {
                            left = x32 * 32 + bit;
                        }
                    }
                    if (x32 * 32 + 31 > right) {
                        var /** @type {?} */ bit = 31;
                        while ((theBits >>> bit) === 0) {
                            bit--;
                        }
                        if ((x32 * 32 + bit) > right) {
                            right = x32 * 32 + bit;
                        }
                    }
                }
            }
        }
        if (right < left || bottom < top) {
            return null;
        }
        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
    };
    /**
     * This is useful in detecting a corner of a 'pure' barcode.
    
    \@return {\@code x,y} coordinate of top-left-most 1 bit, or null if it is all white
     * @return {?}
     */
    BitMatrix.prototype.getTopLeftOnBit = function () {
        var /** @type {?} */ rowSize = this.rowSize;
        var /** @type {?} */ bits = this.bits;
        var /** @type {?} */ bitsOffset = 0;
        while (bitsOffset < bits.length && bits[bitsOffset] == 0) {
            bitsOffset++;
        }
        if (bitsOffset === bits.length) {
            return null;
        }
        var /** @type {?} */ y = bitsOffset / rowSize;
        var /** @type {?} */ x = (bitsOffset % rowSize) * 32;
        var /** @type {?} */ theBits = bits[bitsOffset];
        var /** @type {?} */ bit = 0;
        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {
            bit++;
        }
        x += bit;
        return Int32Array.from([x, y]);
    };
    /**
     * @return {?}
     */
    BitMatrix.prototype.getBottomRightOnBit = function () {
        var /** @type {?} */ rowSize = this.rowSize;
        var /** @type {?} */ bits = this.bits;
        var /** @type {?} */ bitsOffset = bits.length - 1;
        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
            bitsOffset--;
        }
        if (bitsOffset < 0) {
            return null;
        }
        var /** @type {?} */ y = Math.floor(bitsOffset / rowSize);
        var /** @type {?} */ x = Math.floor(bitsOffset % rowSize) * 32;
        var /** @type {?} */ theBits = bits[bitsOffset];
        var /** @type {?} */ bit = 31;
        while ((theBits >>> bit) === 0) {
            bit--;
        }
        x += bit;
        return Int32Array.from([x, y]);
    };
    /**
     * @return {?} The width of the matrix
     */
    BitMatrix.prototype.getWidth = function () {
        return this.width;
    };
    /**
     * @return {?} The height of the matrix
     */
    BitMatrix.prototype.getHeight = function () {
        return this.height;
    };
    /**
     * @return {?} The row size of the matrix
     */
    BitMatrix.prototype.getRowSize = function () {
        return this.rowSize;
    };
    /**
     * @param {?} o
     * @return {?}
     */
    BitMatrix.prototype.equals = function (o) {
        if (!(o instanceof BitMatrix)) {
            return false;
        }
        var /** @type {?} */ other = (o);
        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&
            Arrays.equals(this.bits, other.bits);
    };
    /**
     * @return {?}
     */
    BitMatrix.prototype.hashCode = function () {
        var /** @type {?} */ hash = this.width;
        hash = 31 * hash + this.width;
        hash = 31 * hash + this.height;
        hash = 31 * hash + this.rowSize;
        hash = 31 * hash + Arrays.hashCode(this.bits);
        return hash;
    };
    /**
     * @param {?=} setString
     * @param {?=} unsetString
     * @param {?=} lineSeparator
     * @return {?}
     */
    BitMatrix.prototype.toString = function (setString, unsetString, lineSeparator) {
        if (setString === void 0) { setString = "x"; }
        if (unsetString === void 0) { unsetString = " "; }
        if (lineSeparator === void 0) { lineSeparator = "\n"; }
        return this.buildToString(setString, unsetString, lineSeparator);
    };
    /**
     * @param {?} setString
     * @param {?} unsetString
     * @param {?} lineSeparator
     * @return {?}
     */
    BitMatrix.prototype.buildToString = function (setString, unsetString, lineSeparator) {
        var /** @type {?} */ result = new StringBuilder();
        result.append(lineSeparator);
        for (var /** @type {?} */ y = 0, /** @type {?} */ height = this.height; y < height; y++) {
            for (var /** @type {?} */ x = 0, /** @type {?} */ width = this.width; x < width; x++) {
                result.append(this.get(x, y) ? setString : unsetString);
            }
            result.append(lineSeparator);
        }
        return result.toString();
    };
    /**
     * @return {?}
     */
    BitMatrix.prototype.clone = function () {
        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
    };
    return BitMatrix;
}());

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*namespace com.google.zxing.common {*/
/**
 * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable
for low-end mobile devices which don't have enough CPU or memory to use a local thresholding
algorithm. However, because it picks a global black point, it cannot handle difficult shadows
and gradients.

Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.

\@author dswitkin\@google.com (Daniel Switkin)
\@author Sean Owen
 */
var GlobalHistogramBinarizer = (function (_super) {
    __extends$2(GlobalHistogramBinarizer, _super);
    /**
     * @param {?} source
     */
    function GlobalHistogramBinarizer(source) {
        var _this = _super.call(this, source) || this;
        _this.luminances = GlobalHistogramBinarizer.EMPTY;
        _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
        return _this;
    }
    /**
     * @param {?} y
     * @param {?} row
     * @return {?}
     */
    GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {
        var /** @type {?} */ source = this.getLuminanceSource();
        var /** @type {?} */ width = source.getWidth();
        if (row === undefined || row === null || row.getSize() < width) {
            row = new BitArray(width);
        }
        else {
            row.clear();
        }
        this.initArrays(width);
        var /** @type {?} */ localLuminances = source.getRow(y, this.luminances);
        var /** @type {?} */ localBuckets = this.buckets;
        for (var /** @type {?} */ x = 0; x < width; x++) {
            localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
        }
        var /** @type {?} */ blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        if (width < 3) {
            // Special case for very small images
            for (var /** @type {?} */ x = 0; x < width; x++) {
                if ((localLuminances[x] & 0xff) < blackPoint) {
                    row.set(x);
                }
            }
        }
        else {
            var /** @type {?} */ left = localLuminances[0] & 0xff;
            var /** @type {?} */ center = localLuminances[1] & 0xff;
            for (var /** @type {?} */ x = 1; x < width - 1; x++) {
                var /** @type {?} */ right = localLuminances[x + 1] & 0xff;
                // A simple -1 4 -1 box filter with a weight of 2.
                if (((center * 4) - left - right) / 2 < blackPoint) {
                    row.set(x);
                }
                left = center;
                center = right;
            }
        }
        return row;
    };
    /**
     * @return {?}
     */
    GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {
        var /** @type {?} */ source = this.getLuminanceSource();
        var /** @type {?} */ width = source.getWidth();
        var /** @type {?} */ height = source.getHeight();
        var /** @type {?} */ matrix = new BitMatrix(width, height);
        // Quickly calculates the histogram by sampling four rows from the image. This proved to be
        // more robust on the blackbox tests than sampling a diagonal as we used to do.
        this.initArrays(width);
        var /** @type {?} */ localBuckets = this.buckets;
        for (var /** @type {?} */ y = 1; y < 5; y++) {
            var /** @type {?} */ row = height * y / 5;
            var /** @type {?} */ localLuminances_1 = source.getRow(row, this.luminances);
            var /** @type {?} */ right = Math.floor((width * 4) / 5);
            for (var /** @type {?} */ x = Math.floor(width / 5); x < right; x++) {
                var /** @type {?} */ pixel = localLuminances_1[x] & 0xff;
                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
            }
        }
        var /** @type {?} */ blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        // We delay reading the entire image luminance until the black point estimation succeeds.
        // Although we end up reading four rows twice, it is consistent with our motto of
        // "fail quickly" which is necessary for continuous scanning.
        var /** @type {?} */ localLuminances = source.getMatrix();
        for (var /** @type {?} */ y = 0; y < height; y++) {
            var /** @type {?} */ offset = y * width;
            for (var /** @type {?} */ x = 0; x < width; x++) {
                var /** @type {?} */ pixel = localLuminances[offset + x] & 0xff;
                if (pixel < blackPoint) {
                    matrix.set(x, y);
                }
            }
        }
        return matrix;
    };
    /**
     * @param {?} source
     * @return {?}
     */
    GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {
        return new GlobalHistogramBinarizer(source);
    };
    /**
     * @param {?} luminanceSize
     * @return {?}
     */
    GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {
        if (this.luminances.length < luminanceSize) {
            this.luminances = new Uint8ClampedArray(luminanceSize);
        }
        var /** @type {?} */ buckets = this.buckets;
        for (var /** @type {?} */ x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {
            buckets[x] = 0;
        }
    };
    /**
     * @param {?} buckets
     * @return {?}
     */
    GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {
        // Find the tallest peak in the histogram.
        var /** @type {?} */ numBuckets = buckets.length;
        var /** @type {?} */ maxBucketCount = 0;
        var /** @type {?} */ firstPeak = 0;
        var /** @type {?} */ firstPeakSize = 0;
        for (var /** @type {?} */ x = 0; x < numBuckets; x++) {
            if (buckets[x] > firstPeakSize) {
                firstPeak = x;
                firstPeakSize = buckets[x];
            }
            if (buckets[x] > maxBucketCount) {
                maxBucketCount = buckets[x];
            }
        }
        // Find the second-tallest peak which is somewhat far from the tallest peak.
        var /** @type {?} */ secondPeak = 0;
        var /** @type {?} */ secondPeakScore = 0;
        for (var /** @type {?} */ x = 0; x < numBuckets; x++) {
            var /** @type {?} */ distanceToBiggest = x - firstPeak;
            // Encourage more distant second peaks by multiplying by square of distance.
            var /** @type {?} */ score = buckets[x] * distanceToBiggest * distanceToBiggest;
            if (score > secondPeakScore) {
                secondPeak = x;
                secondPeakScore = score;
            }
        }
        // Make sure firstPeak corresponds to the black peak.
        if (firstPeak > secondPeak) {
            var /** @type {?} */ temp = firstPeak;
            firstPeak = secondPeak;
            secondPeak = temp;
        }
        // If there is too little contrast in the image to pick a meaningful black point, throw rather
        // than waste time trying to decode the image, and risk false positives.
        if (secondPeak - firstPeak <= numBuckets / 16) {
            throw new Exception(Exception.NotFoundException);
        }
        // Find a valley between them that is low and closer to the white peak.
        var /** @type {?} */ bestValley = secondPeak - 1;
        var /** @type {?} */ bestValleyScore = -1;
        for (var /** @type {?} */ x = secondPeak - 1; x > firstPeak; x--) {
            var /** @type {?} */ fromFirst = x - firstPeak;
            var /** @type {?} */ score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);
            if (score > bestValleyScore) {
                bestValley = x;
                bestValleyScore = score;
            }
        }
        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
    };
    return GlobalHistogramBinarizer;
}(Binarizer));
GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * This class implements a local thresholding algorithm, which while slower than the
GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for
high frequency images of barcodes with black data on white backgrounds. For this application,
it does a much better job than a global blackpoint with severe shadows and gradients.
However it tends to produce artifacts on lower frequency images and is therefore not
a good general purpose binarizer for uses outside ZXing.

This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,
and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already
inherently local, and only fails for horizontal gradients. We can revisit that problem later,
but for now it was not a win to use local blocks for 1D.

This Binarizer is the default for the unit tests and the recommended class for library users.

\@author dswitkin\@google.com (Daniel Switkin)
 */
var HybridBinarizer = (function (_super) {
    __extends$1(HybridBinarizer, _super);
    /**
     * @param {?} source
     */
    function HybridBinarizer(source) {
        var _this = _super.call(this, source) || this;
        _this.matrix = null;
        return _this;
    }
    /**
     * @return {?}
     */
    HybridBinarizer.prototype.getBlackMatrix = function () {
        if (this.matrix !== null) {
            return this.matrix;
        }
        var /** @type {?} */ source = this.getLuminanceSource();
        var /** @type {?} */ width = source.getWidth();
        var /** @type {?} */ height = source.getHeight();
        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {
            var /** @type {?} */ luminances = source.getMatrix();
            var /** @type {?} */ subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;
            if ((width & HybridBinarizer.BLOCK_SIZE_MASK) != 0) {
                subWidth++;
            }
            var /** @type {?} */ subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;
            if ((height & HybridBinarizer.BLOCK_SIZE_MASK) != 0) {
                subHeight++;
            }
            var /** @type {?} */ blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
            var /** @type {?} */ newMatrix = new BitMatrix(width, height);
            HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
            this.matrix = newMatrix;
        }
        else {
            // If the image is too small, fall back to the global histogram approach.
            this.matrix = _super.prototype.getBlackMatrix.call(this);
        }
        return this.matrix;
    };
    /**
     * @param {?} source
     * @return {?}
     */
    HybridBinarizer.prototype.createBinarizer = function (source) {
        return new HybridBinarizer(source);
    };
    /**
     * For each block in the image, calculate the average black point using a 5x5 grid
    of the blocks around it. Also handles the corner cases (fractional blocks are computed based
    on the last pixels in the row/column which are also used in the previous block).
     * @param {?} luminances
     * @param {?} subWidth
     * @param {?} subHeight
     * @param {?} width
     * @param {?} height
     * @param {?} blackPoints
     * @param {?} matrix
     * @return {?}
     */
    HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {
        var /** @type {?} */ maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        var /** @type {?} */ maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        for (var /** @type {?} */ y = 0; y < subHeight; y++) {
            var /** @type {?} */ yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
            if (yoffset > maxYOffset) {
                yoffset = maxYOffset;
            }
            var /** @type {?} */ top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);
            for (var /** @type {?} */ x = 0; x < subWidth; x++) {
                var /** @type {?} */ xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
                if (xoffset > maxXOffset) {
                    xoffset = maxXOffset;
                }
                var /** @type {?} */ left = HybridBinarizer.cap(x, 2, subWidth - 3);
                var /** @type {?} */ sum = 0;
                for (var /** @type {?} */ z = -2; z <= 2; z++) {
                    var /** @type {?} */ blackRow = blackPoints[top_1 + z];
                    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
                }
                var /** @type {?} */ average = sum / 25;
                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
            }
        }
    };
    /**
     * @param {?} value
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {
        return value < min ? min : value > max ? max : value;
    };
    /**
     * Applies a single threshold to a block of pixels.
     * @param {?} luminances
     * @param {?} xoffset
     * @param {?} yoffset
     * @param {?} threshold
     * @param {?} stride
     * @param {?} matrix
     * @return {?}
     */
    HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {
        for (var /** @type {?} */ y = 0, /** @type {?} */ offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {
            for (var /** @type {?} */ x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {
                // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.
                if ((luminances[offset + x] & 0xFF) <= threshold) {
                    matrix.set(xoffset + x, yoffset + y);
                }
            }
        }
    };
    /**
     * Calculates a single black point for each block of pixels and saves it away.
    See the following thread for a discussion of this algorithm:
     http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
     * @param {?} luminances
     * @param {?} subWidth
     * @param {?} subHeight
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {
        var /** @type {?} */ maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        var /** @type {?} */ maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        var /** @type {?} */ blackPoints = new Array(subHeight); //subWidth
        for (var /** @type {?} */ y = 0; y < subHeight; y++) {
            blackPoints[y] = new Int32Array(subWidth);
            var /** @type {?} */ yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
            if (yoffset > maxYOffset) {
                yoffset = maxYOffset;
            }
            for (var /** @type {?} */ x = 0; x < subWidth; x++) {
                var /** @type {?} */ xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
                if (xoffset > maxXOffset) {
                    xoffset = maxXOffset;
                }
                var /** @type {?} */ sum = 0;
                var /** @type {?} */ min = 0xFF;
                var /** @type {?} */ max = 0;
                for (var /** @type {?} */ yy = 0, /** @type {?} */ offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                    for (var /** @type {?} */ xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                        var /** @type {?} */ pixel = luminances[offset + xx] & 0xFF;
                        sum += pixel;
                        // still looking for good contrast
                        if (pixel < min) {
                            min = pixel;
                        }
                        if (pixel > max) {
                            max = pixel;
                        }
                    }
                    // short-circuit min/max tests once dynamic range is met
                    if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {
                        // finish the rest of the rows quickly
                        for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                            for (var /** @type {?} */ xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                                sum += luminances[offset + xx] & 0xFF;
                            }
                        }
                    }
                }
                // The default estimate is the average of the values in the block.
                var /** @type {?} */ average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);
                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {
                    // If variation within the block is low, assume this is a block with only light or only
                    // dark pixels. In that case we do not want to use the average, as it would divide this
                    // low contrast area into black and white pixels, essentially creating data out of noise.
                    //
                    // The default assumption is that the block is light/background. Since no estimate for
                    // the level of dark pixels exists locally, use half the min for the block.
                    average = min / 2;
                    if (y > 0 && x > 0) {
                        // Correct the "white background" assumption for blocks that have neighbors by comparing
                        // the pixels in this block to the previously calculated black points. This is based on
                        // the fact that dark barcode symbology is always surrounded by some amount of light
                        // background for which reasonable black point estimates were made. The bp estimated at
                        // the boundaries is used for the interior.
                        // The (min < bp) is arbitrary but works better than other heuristics that were tried.
                        var /** @type {?} */ averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;
                        if (min < averageNeighborBlackPoint) {
                            average = averageNeighborBlackPoint;
                        }
                    }
                }
                blackPoints[y][x] = average;
            }
        }
        return blackPoints;
    };
    return HybridBinarizer;
}(GlobalHistogramBinarizer));
HybridBinarizer.BLOCK_SIZE_POWER = 3;
HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER;
HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1;
HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;
HybridBinarizer.MIN_DYNAMIC_RANGE = 24;

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The purpose of this class hierarchy is to abstract different bitmap implementations across
platforms into a standard interface for requesting greyscale luminance values. The interface
only provides immutable methods; therefore crop and rotation create copies. This is to ensure
that one Reader does not modify the original luminance source and leave it in an unknown state
for other Readers in the chain.

\@author dswitkin\@google.com (Daniel Switkin)
 * @abstract
 */
var LuminanceSource = (function () {
    /**
     * @param {?} width
     * @param {?} height
     */
    function LuminanceSource(width /*int*/, height /*int*/) {
        this.width = width; /*int*/
        this.height = height; /*int*/
    }
    /**
     * Fetches one row of luminance data from the underlying platform's bitmap. Values range from
    0 (black) to 255 (white). Because Java does not have an unsigned byte type, callers will have
    to bitwise and with 0xff for each value. It is preferable for implementations of this method
    to only fetch this row rather than the whole image, since no 2D Readers may be installed and
    getMatrix() may never be called.
    
    \@param y The row to fetch, which must be in [0,getHeight())
    \@param row An optional preallocated array. If null or too small, it will be ignored.
               Always use the returned object, and ignore the .length of the array.
    \@return An array containing the luminance data.
     * @abstract
     * @param {?} y
     * @param {?=} row
     * @return {?}
     */
    LuminanceSource.prototype.getRow = function (y /*int*/, row) { };
    /**
     * Fetches luminance data for the underlying bitmap. Values should be fetched using:
    {\@code int luminance = array[y * width + x] & 0xff}
    
    \@return A row-major 2D array of luminance values. Do not use result.length as it may be
            larger than width * height bytes on some platforms. Do not modify the contents
            of the result.
     * @abstract
     * @return {?}
     */
    LuminanceSource.prototype.getMatrix = function () { };
    /**
     * @return {?} The width of the bitmap.
     */
    LuminanceSource.prototype.getWidth = function () {
        return this.width;
    };
    /**
     * @return {?} The height of the bitmap.
     */
    LuminanceSource.prototype.getHeight = function () {
        return this.height;
    };
    /**
     * @return {?} Whether this subclass supports cropping.
     */
    LuminanceSource.prototype.isCropSupported = function () {
        return false;
    };
    /**
     * Returns a new object with cropped image data. Implementations may keep a reference to the
    original data rather than a copy. Only callable if isCropSupported() is true.
    
    \@param left The left coordinate, which must be in [0,getWidth())
    \@param top The top coordinate, which must be in [0,getHeight())
    \@param width The width of the rectangle to crop.
    \@param height The height of the rectangle to crop.
    \@return A cropped version of this object.
     * @param {?} left
     * @param {?} top
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    LuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        throw new Exception(Exception.UnsupportedOperationException, "This luminance source does not support cropping.");
    };
    /**
     * @return {?} Whether this subclass supports counter-clockwise rotation.
     */
    LuminanceSource.prototype.isRotateSupported = function () {
        return false;
    };
    /**
     * @abstract
     * @return {?} a wrapper of this {\@code LuminanceSource} which inverts the luminances it returns -- black becomes
     */
    LuminanceSource.prototype.invert = function () { };
    /**
     * Returns a new object with rotated image data by 90 degrees counterclockwise.
    Only callable if {\@link #isRotateSupported()} is true.
    
    \@return A rotated version of this object.
     * @return {?}
     */
    LuminanceSource.prototype.rotateCounterClockwise = function () {
        throw new Exception(Exception.UnsupportedOperationException, "This luminance source does not support rotation by 90 degrees.");
    };
    /**
     * Returns a new object with rotated image data by 45 degrees counterclockwise.
    Only callable if {\@link #isRotateSupported()} is true.
    
    \@return A rotated version of this object.
     * @return {?}
     */
    LuminanceSource.prototype.rotateCounterClockwise45 = function () {
        throw new Exception(Exception.UnsupportedOperationException, "This luminance source does not support rotation by 45 degrees.");
    };
    /**
     * @return {?}
     */
    LuminanceSource.prototype.toString = function () {
        var /** @type {?} */ row = new Uint8ClampedArray(this.width);
        var /** @type {?} */ result = new StringBuilder();
        for (var /** @type {?} */ y = 0; y < this.height; y++) {
            var /** @type {?} */ sourceRow = this.getRow(y, row);
            for (var /** @type {?} */ x = 0; x < this.width; x++) {
                var /** @type {?} */ luminance = sourceRow[x] & 0xFF;
                var /** @type {?} */ c = void 0;
                if (luminance < 0x40) {
                    c = '#';
                }
                else if (luminance < 0x80) {
                    c = '+';
                }
                else if (luminance < 0xC0) {
                    c = '.';
                }
                else {
                    c = ' ';
                }
                result.append(c);
            }
            result.append('\n');
        }
        return result.toString();
    };
    return LuminanceSource;
}());

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * A wrapper implementation of {\@link LuminanceSource} which inverts the luminances it returns -- black becomes
white and vice versa, and each value becomes (255-value).

\@author Sean Owen
 */
var InvertedLuminanceSource = (function (_super) {
    __extends$4(InvertedLuminanceSource, _super);
    /**
     * @param {?} delegate
     */
    function InvertedLuminanceSource(delegate) {
        var _this = _super.call(this, delegate.getWidth(), delegate.getHeight()) || this;
        _this.delegate = delegate;
        return _this;
    }
    /**
     * @param {?} y
     * @param {?=} row
     * @return {?}
     */
    InvertedLuminanceSource.prototype.getRow = function (y /*int*/, row) {
        var /** @type {?} */ sourceRow = this.delegate.getRow(y, row);
        var /** @type {?} */ width = this.getWidth();
        for (var /** @type {?} */ i = 0; i < width; i++) {
            sourceRow[i] = (255 - (sourceRow[i] & 0xFF));
        }
        return sourceRow;
    };
    /**
     * @return {?}
     */
    InvertedLuminanceSource.prototype.getMatrix = function () {
        var /** @type {?} */ matrix = this.delegate.getMatrix();
        var /** @type {?} */ length = this.getWidth() * this.getHeight();
        var /** @type {?} */ invertedMatrix = new Uint8ClampedArray(length);
        for (var /** @type {?} */ i = 0; i < length; i++) {
            invertedMatrix[i] = (255 - (matrix[i] & 0xFF));
        }
        return invertedMatrix;
    };
    /**
     * @return {?}
     */
    InvertedLuminanceSource.prototype.isCropSupported = function () {
        return this.delegate.isCropSupported();
    };
    /**
     * @param {?} left
     * @param {?} top
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    InvertedLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
    };
    /**
     * @return {?}
     */
    InvertedLuminanceSource.prototype.isRotateSupported = function () {
        return this.delegate.isRotateSupported();
    };
    /**
     * @return {?}
     */
    InvertedLuminanceSource.prototype.invert = function () {
        return this.delegate;
    };
    /**
     * @return {?}
     */
    InvertedLuminanceSource.prototype.rotateCounterClockwise = function () {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
    };
    /**
     * @return {?}
     */
    InvertedLuminanceSource.prototype.rotateCounterClockwise45 = function () {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
    };
    return InvertedLuminanceSource;
}(LuminanceSource));

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var HTMLCanvasElementLuminanceSource = (function (_super) {
    __extends$3(HTMLCanvasElementLuminanceSource, _super);
    /**
     * @param {?} canvas
     */
    function HTMLCanvasElementLuminanceSource(canvas) {
        var _this = _super.call(this, canvas.width, canvas.height) || this;
        _this.canvas = canvas;
        _this.tempCanvasElement = null;
        _this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
        return _this;
    }
    /**
     * @param {?} canvas
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData = function (canvas) {
        var /** @type {?} */ imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
    };
    /**
     * @param {?} imageBuffer
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.toGrayscaleBuffer = function (imageBuffer, width, height) {
        var /** @type {?} */ grayscaleBuffer = new Uint8ClampedArray(width * height);
        for (var /** @type {?} */ i = 0, /** @type {?} */ j = 0, /** @type {?} */ length_1 = imageBuffer.length; i < length_1; i += 4, j++) {
            var /** @type {?} */ gray = void 0;
            var /** @type {?} */ alpha = imageBuffer[i + 4];
            // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent
            // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a
            // barcode image. Force any such pixel to be white:
            if (alpha === 0) {
                gray = 0xFF;
            }
            else {
                var /** @type {?} */ pixelR = imageBuffer[i];
                var /** @type {?} */ pixelG = imageBuffer[i + 1];
                var /** @type {?} */ pixelB = imageBuffer[i + 2];
                // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC), 
                // (306*R) >> 10 is approximately equal to R*0.299, and so on.
                // 0x200 >> 10 is 0.5, it implements rounding.
                gray = (306 * pixelR +
                    601 * pixelG +
                    117 * pixelB +
                    0x200) >> 10;
            }
            grayscaleBuffer[j] = gray;
        }
        return grayscaleBuffer;
    };
    /**
     * @param {?} y
     * @param {?} row
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.getRow = function (y /*int*/, row) {
        if (y < 0 || y >= this.getHeight()) {
            throw new Exception(Exception.IllegalArgumentException, "Requested row is outside the image: " + y);
        }
        var /** @type {?} */ width = this.getWidth();
        var /** @type {?} */ start = y * width;
        if (row === null) {
            row = this.buffer.slice(start, start + width);
        }
        else {
            if (row.length < width) {
                row = new Uint8ClampedArray(width);
            }
            // The underlying raster of image consists of bytes with the luminance values
            // TODO: can avoid set/slice?
            row.set(this.buffer.slice(start, start + width));
        }
        return row;
    };
    /**
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.getMatrix = function () {
        return this.buffer;
    };
    /**
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.isCropSupported = function () {
        return true;
    };
    /**
     * @param {?} left
     * @param {?} top
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        this.crop(left, top, width, height);
        return this;
    };
    /**
     * This is always true, since the image is a gray-scale image.
    
    \@return true
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.isRotateSupported = function () {
        return true;
    };
    /**
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise = function () {
        this.rotate(-90);
        return this;
    };
    /**
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise45 = function () {
        this.rotate(-45);
        return this;
    };
    /**
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.getTempCanvasElement = function () {
        if (null === this.tempCanvasElement) {
            var /** @type {?} */ tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');
            tempCanvasElement.style.width = this.canvas.width + "px";
            tempCanvasElement.style.height = this.canvas.height + "px";
        }
        return this.tempCanvasElement;
    };
    /**
     * @param {?} angle
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.rotate = function (angle) {
        var /** @type {?} */ tempCanvasElement = this.getTempCanvasElement();
        var /** @type {?} */ tempContext = tempCanvasElement.getContext('2d');
        tempContext.rotate(angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS);
        tempContext.drawImage(this.canvas, 0, 0);
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
        return this;
    };
    /**
     * @return {?}
     */
    HTMLCanvasElementLuminanceSource.prototype.invert = function () {
        return new InvertedLuminanceSource(this);
    };
    return HTMLCanvasElementLuminanceSource;
}(LuminanceSource));
HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;

/**
 * General math-related and numeric utility functions.
 */
var MathUtils = (function () {
    function MathUtils() {
    }
    /**
     * @return {?}
     */
    MathUtils.prototype.MathUtils = function () {
    };
    /**
     * Ends up being a bit faster than {\@link Math#round(float)}. This merely rounds its
    argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut
    differ slightly from {\@link Math#round(float)} in that half rounds down for negative
    values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.
    
    \@param d real value to round
    \@return nearest {\@code int}
     * @param {?} d
     * @return {?}
     */
    MathUtils.round = function (d /*float*/) {
        if (NaN === d)
            return 0;
        if (d <= Number.MIN_SAFE_INTEGER)
            return Number.MIN_SAFE_INTEGER;
        if (d >= Number.MAX_SAFE_INTEGER)
            return Number.MAX_SAFE_INTEGER;
        return (d + (d < 0.0 ? -0.5 : 0.5)) | 0;
    };
    /**
     * @param {?} aX point A x coordinate
     * @param {?} aY
     * @param {?} bX
     * @param {?} bY
     * @return {?}
     */
    MathUtils.distance = function (aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {
        var /** @type {?} */ xDiff = aX - bX;
        var /** @type {?} */ yDiff = aY - bY;
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    };
    /**
     * @param {?} array values to sum
     * @return {?}
     */
    MathUtils.sum = function (array) {
        var /** @type {?} */ count = 0;
        for (var /** @type {?} */ i = 0, /** @type {?} */ length_1 = array.length; i != length_1; i++) {
            var /** @type {?} */ a = array[i];
            count += a;
        }
        return count;
    };
    return MathUtils;
}());

var Float = (function () {
    function Float() {
    }
    /**
     * @param {?} f
     * @return {?}
     */
    Float.floatToIntBits = function (f) {
        return f;
    };
    return Float;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing {*/
/**
 * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this
would be the location of a finder pattern or the corner of the barcode, for example.</p>

\@author Sean Owen
 */
var ResultPoint = (function () {
    /**
     * @param {?} x
     * @param {?} y
     */
    function ResultPoint(x /*float*/, y /*float*/) {
        this.x = x; /*float*/
        this.y = y; /*float*/
    }
    /**
     * @return {?}
     */
    ResultPoint.prototype.getX = function () {
        return this.x;
    };
    /**
     * @return {?}
     */
    ResultPoint.prototype.getY = function () {
        return this.y;
    };
    /**
     * @param {?} other
     * @return {?}
     */
    ResultPoint.prototype.equals = function (other) {
        if (other instanceof ResultPoint) {
            var /** @type {?} */ otherPoint = (other);
            return this.x == otherPoint.x && this.y == otherPoint.y;
        }
        return false;
    };
    /**
     * @return {?}
     */
    ResultPoint.prototype.hashCode = function () {
        return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);
    };
    /**
     * @return {?}
     */
    ResultPoint.prototype.toString = function () {
        return "(" + this.x + ',' + this.y + ')';
    };
    /**
     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC
    and BC is less than AC, and the angle between BC and BA is less than 180 degrees.
    
    \@param patterns array of three {\@code ResultPoint} to order
     * @param {?} patterns
     * @return {?}
     */
    ResultPoint.orderBestPatterns = function (patterns) {
        // Find distances between pattern centers
        var /** @type {?} */ zeroOneDistance = this.distance(patterns[0], patterns[1]);
        var /** @type {?} */ oneTwoDistance = this.distance(patterns[1], patterns[2]);
        var /** @type {?} */ zeroTwoDistance = this.distance(patterns[0], patterns[2]);
        var /** @type {?} */ pointA;
        var /** @type {?} */ pointB;
        var /** @type {?} */ pointC;
        // Assume one closest to other two is B; A and C will just be guesses at first
        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
            pointB = patterns[0];
            pointA = patterns[1];
            pointC = patterns[2];
        }
        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
            pointB = patterns[1];
            pointA = patterns[0];
            pointC = patterns[2];
        }
        else {
            pointB = patterns[2];
            pointA = patterns[0];
            pointC = patterns[1];
        }
        // Use cross product to figure out whether A and C are correct or flipped.
        // This asks whether BC x BA has a positive z component, which is the arrangement
        // we want for A, B, C. If it's negative, then we've got it flipped around and
        // should swap A and C.
        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {
            var /** @type {?} */ temp = pointA;
            pointA = pointC;
            pointC = temp;
        }
        patterns[0] = pointA;
        patterns[1] = pointB;
        patterns[2] = pointC;
    };
    /**
     * @param {?} pattern1 first pattern
     * @param {?} pattern2
     * @return {?}
     */
    ResultPoint.distance = function (pattern1, pattern2) {
        return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
    };
    /**
     * Returns the z component of the cross product between vectors BC and BA.
     * @param {?} pointA
     * @param {?} pointB
     * @param {?} pointC
     * @return {?}
     */
    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {
        var /** @type {?} */ bX = pointB.x;
        var /** @type {?} */ bY = pointB.y;
        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));
    };
    return ResultPoint;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing {*/
/*import java.util.EnumMap;*/
/*import java.util.Map;*/
/**
 * <p>Encapsulates the result of decoding a barcode within an image.</p>

\@author Sean Owen
 */
var Result = (function () {
    /**
     * @param {?} text
     * @param {?} rawBytes
     * @param {?} numBits
     * @param {?} resultPoints
     * @param {?} format
     * @param {?} timestamp
     */
    function Result(text, rawBytes, numBits /*int*/, resultPoints, format, timestamp /*long*/) {
        this.text = text;
        this.rawBytes = rawBytes;
        this.numBits = numBits; /*int*/
        this.resultPoints = resultPoints;
        this.format = format;
        this.timestamp = timestamp; /*long*/
        this.text = text;
        this.rawBytes = rawBytes;
        if (undefined === numBits || null === numBits) {
            this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;
        }
        else {
            this.numBits = numBits;
        }
        this.resultPoints = resultPoints;
        this.format = format;
        this.resultMetadata = null;
        if (undefined === timestamp || null === timestamp) {
            this.timestamp = System.currentTimeMillis();
        }
        else {
            this.timestamp = timestamp;
        }
    }
    /**
     * @return {?} raw text encoded by the barcode
     */
    Result.prototype.getText = function () {
        return this.text;
    };
    /**
     * @return {?} raw bytes encoded by the barcode, if applicable, otherwise {\@code null}
     */
    Result.prototype.getRawBytes = function () {
        return this.rawBytes;
    };
    /**
     * @return {?} how many bits of {\@link #getRawBytes()} are valid; typically 8 times its length
     */
    Result.prototype.getNumBits = function () {
        return this.numBits;
    };
    /**
     * @return {?} points related to the barcode in the image. These are typically points
     */
    Result.prototype.getResultPoints = function () {
        return this.resultPoints;
    };
    /**
     * @return {?}
     */
    Result.prototype.getBarcodeFormat = function () {
        return this.format;
    };
    /**
     * @return {?}
     */
    Result.prototype.getResultMetadata = function () {
        return this.resultMetadata;
    };
    /**
     * @param {?} type
     * @param {?} value
     * @return {?}
     */
    Result.prototype.putMetadata = function (type, value) {
        if (this.resultMetadata === null) {
            this.resultMetadata = new Map();
        }
        this.resultMetadata.set(type, value);
    };
    /**
     * @param {?} metadata
     * @return {?}
     */
    Result.prototype.putAllMetadata = function (metadata) {
        if (metadata !== null) {
            if (this.resultMetadata === null) {
                this.resultMetadata = metadata;
            }
            else {
                this.resultMetadata = new Map(metadata);
            }
        }
    };
    /**
     * @param {?} newPoints
     * @return {?}
     */
    Result.prototype.addResultPoints = function (newPoints) {
        var /** @type {?} */ oldPoints = this.resultPoints;
        if (oldPoints === null) {
            this.resultPoints = newPoints;
        }
        else if (newPoints !== null && newPoints.length > 0) {
            var /** @type {?} */ allPoints = new ResultPoint[oldPoints.length + newPoints.length];
            System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
            System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
            this.resultPoints = allPoints;
        }
    };
    /**
     * @return {?}
     */
    Result.prototype.getTimestamp = function () {
        return this.timestamp;
    };
    /**
     * @return {?}
     */
    Result.prototype.toString = function () {
        return this.text;
    };
    return Result;
}());

var ResultMetadataType = {};
ResultMetadataType.OTHER = 0;
ResultMetadataType.ORIENTATION = 1;
ResultMetadataType.BYTE_SEGMENTS = 2;
ResultMetadataType.ERROR_CORRECTION_LEVEL = 3;
ResultMetadataType.ISSUE_NUMBER = 4;
ResultMetadataType.SUGGESTED_PRICE = 5;
ResultMetadataType.POSSIBLE_COUNTRY = 6;
ResultMetadataType.UPC_EAN_EXTENSION = 7;
ResultMetadataType.PDF417_EXTRA_METADATA = 8;
ResultMetadataType.STRUCTURED_APPEND_SEQUENCE = 9;
ResultMetadataType.STRUCTURED_APPEND_PARITY = 10;
ResultMetadataType[ResultMetadataType.OTHER] = "OTHER";
ResultMetadataType[ResultMetadataType.ORIENTATION] = "ORIENTATION";
ResultMetadataType[ResultMetadataType.BYTE_SEGMENTS] = "BYTE_SEGMENTS";
ResultMetadataType[ResultMetadataType.ERROR_CORRECTION_LEVEL] = "ERROR_CORRECTION_LEVEL";
ResultMetadataType[ResultMetadataType.ISSUE_NUMBER] = "ISSUE_NUMBER";
ResultMetadataType[ResultMetadataType.SUGGESTED_PRICE] = "SUGGESTED_PRICE";
ResultMetadataType[ResultMetadataType.POSSIBLE_COUNTRY] = "POSSIBLE_COUNTRY";
ResultMetadataType[ResultMetadataType.UPC_EAN_EXTENSION] = "UPC_EAN_EXTENSION";
ResultMetadataType[ResultMetadataType.PDF417_EXTRA_METADATA] = "PDF417_EXTRA_METADATA";
ResultMetadataType[ResultMetadataType.STRUCTURED_APPEND_SEQUENCE] = "STRUCTURED_APPEND_SEQUENCE";
ResultMetadataType[ResultMetadataType.STRUCTURED_APPEND_PARITY] = "STRUCTURED_APPEND_PARITY";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.common.reedsolomon {*/
/**
 * <p>Represents a polynomial whose coefficients are elements of a GF.
Instances of this class are immutable.</p>

<p>Much credit is due to William Rucklidge since portions of this code are an indirect
port of his C++ Reed-Solomon implementation.</p>

\@author Sean Owen
 */
var GenericGFPoly = (function () {
    /**
     * @param {?} field the {\@link GenericGF} instance representing the field to use
     * @param {?} coefficients
     */
    function GenericGFPoly(field, coefficients) {
        if (coefficients.length === 0) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        this.field = field;
        var coefficientsLength = coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] === 0) {
            // Leading term must be non-zero for anything except the constant polynomial "0"
            var firstNonZero = 1;
            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                firstNonZero++;
            }
            if (firstNonZero === coefficientsLength) {
                this.coefficients = Int32Array.from([0]);
            }
            else {
                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
                System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
            }
        }
        else {
            this.coefficients = coefficients;
        }
    }
    /**
     * @return {?}
     */
    GenericGFPoly.prototype.getCoefficients = function () {
        return this.coefficients;
    };
    /**
     * @return {?} degree of this polynomial
     */
    GenericGFPoly.prototype.getDegree = function () {
        return this.coefficients.length - 1;
    };
    /**
     * @return {?} true iff this polynomial is the monomial "0"
     */
    GenericGFPoly.prototype.isZero = function () {
        return this.coefficients[0] === 0;
    };
    /**
     * @param {?} degree
     * @return {?} coefficient of x^degree term in this polynomial
     */
    GenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {
        return this.coefficients[this.coefficients.length - 1 - degree];
    };
    /**
     * @param {?} a
     * @return {?} evaluation of this polynomial at a given point
     */
    GenericGFPoly.prototype.evaluateAt = function (a /*int*/) {
        if (a === 0) {
            // Just return the x^0 coefficient
            return this.getCoefficient(0);
        }
        var /** @type {?} */ coefficients = this.coefficients;
        var /** @type {?} */ result;
        if (a === 1) {
            // Just the sum of the coefficients
            result = 0;
            for (var /** @type {?} */ i = 0, /** @type {?} */ length_1 = coefficients.length; i !== length_1; i++) {
                var /** @type {?} */ coefficient = coefficients[i];
                result = GenericGF.addOrSubtract(result, coefficient);
            }
            return result;
        }
        result = coefficients[0];
        var /** @type {?} */ size = coefficients.length;
        var /** @type {?} */ field = this.field;
        for (var /** @type {?} */ i = 1; i < size; i++) {
            result = GenericGF.addOrSubtract(field.multiply(a, result), coefficients[i]);
        }
        return result;
    };
    /**
     * @param {?} other
     * @return {?}
     */
    GenericGFPoly.prototype.addOrSubtract = function (other) {
        if (!this.field.equals(other.field)) {
            throw new Exception(Exception.IllegalArgumentException, "GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero()) {
            return other;
        }
        if (other.isZero()) {
            return this;
        }
        var /** @type {?} */ smallerCoefficients = this.coefficients;
        var /** @type {?} */ largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
            var /** @type {?} */ temp = smallerCoefficients;
            smallerCoefficients = largerCoefficients;
            largerCoefficients = temp;
        }
        var /** @type {?} */ sumDiff = new Int32Array(largerCoefficients.length);
        var /** @type {?} */ lengthDiff = largerCoefficients.length - smallerCoefficients.length;
        // Copy high-order terms only found in higher-degree polynomial's coefficients
        System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (var /** @type {?} */ i = lengthDiff; i < largerCoefficients.length; i++) {
            sumDiff[i] = GenericGF.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
        }
        return new GenericGFPoly(this.field, sumDiff);
    };
    /**
     * @param {?} other
     * @return {?}
     */
    GenericGFPoly.prototype.multiply = function (other) {
        if (!this.field.equals(other.field)) {
            throw new Exception(Exception.IllegalArgumentException, "GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero() || other.isZero()) {
            return this.field.getZero();
        }
        var /** @type {?} */ aCoefficients = this.coefficients;
        var /** @type {?} */ aLength = aCoefficients.length;
        var /** @type {?} */ bCoefficients = other.coefficients;
        var /** @type {?} */ bLength = bCoefficients.length;
        var /** @type {?} */ product = new Int32Array(aLength + bLength - 1);
        var /** @type {?} */ field = this.field;
        for (var /** @type {?} */ i = 0; i < aLength; i++) {
            var /** @type {?} */ aCoeff = aCoefficients[i];
            for (var /** @type {?} */ j = 0; j < bLength; j++) {
                product[i + j] = GenericGF.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));
            }
        }
        return new GenericGFPoly(field, product);
    };
    /**
     * @param {?} scalar
     * @return {?}
     */
    GenericGFPoly.prototype.multiplyScalar = function (scalar /*int*/) {
        if (scalar === 0) {
            return this.field.getZero();
        }
        if (scalar === 1) {
            return this;
        }
        var /** @type {?} */ size = this.coefficients.length;
        var /** @type {?} */ field = this.field;
        var /** @type {?} */ product = new Int32Array(size);
        var /** @type {?} */ coefficients = this.coefficients;
        for (var /** @type {?} */ i = 0; i < size; i++) {
            product[i] = field.multiply(coefficients[i], scalar);
        }
        return new GenericGFPoly(field, product);
    };
    /**
     * @param {?} degree
     * @param {?} coefficient
     * @return {?}
     */
    GenericGFPoly.prototype.multiplyByMonomial = function (degree /*int*/, coefficient /*int*/) {
        if (degree < 0) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        if (coefficient === 0) {
            return this.field.getZero();
        }
        var /** @type {?} */ coefficients = this.coefficients;
        var /** @type {?} */ size = coefficients.length;
        var /** @type {?} */ product = new Int32Array(size + degree);
        var /** @type {?} */ field = this.field;
        for (var /** @type {?} */ i = 0; i < size; i++) {
            product[i] = field.multiply(coefficients[i], coefficient);
        }
        return new GenericGFPoly(field, product);
    };
    /**
     * @param {?} other
     * @return {?}
     */
    GenericGFPoly.prototype.divide = function (other) {
        if (!this.field.equals(other.field)) {
            throw new Exception(Exception.IllegalArgumentException, "GenericGFPolys do not have same GenericGF field");
        }
        if (other.isZero()) {
            throw new Exception(Exception.IllegalArgumentException, "Divide by 0");
        }
        var /** @type {?} */ field = this.field;
        var /** @type {?} */ quotient = field.getZero();
        var /** @type {?} */ remainder = this;
        var /** @type {?} */ denominatorLeadingTerm = other.getCoefficient(other.getDegree());
        var /** @type {?} */ inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
            var /** @type {?} */ degreeDifference = remainder.getDegree() - other.getDegree();
            var /** @type {?} */ scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
            var /** @type {?} */ term = other.multiplyByMonomial(degreeDifference, scale);
            var /** @type {?} */ iterationQuotient = field.buildMonomial(degreeDifference, scale);
            quotient = quotient.addOrSubtract(iterationQuotient);
            remainder = remainder.addOrSubtract(term);
        }
        return [quotient, remainder];
    };
    /**
     * @return {?}
     */
    GenericGFPoly.prototype.toString = function () {
        var /** @type {?} */ result = "";
        for (var /** @type {?} */ degree = this.getDegree(); degree >= 0; degree--) {
            var /** @type {?} */ coefficient = this.getCoefficient(degree);
            if (coefficient != 0) {
                if (coefficient < 0) {
                    result += " - ";
                    coefficient = -coefficient;
                }
                else {
                    if (result.length > 0) {
                        result += " + ";
                    }
                }
                if (degree === 0 || coefficient != 1) {
                    var /** @type {?} */ alphaPower = this.field.log(coefficient);
                    if (alphaPower === 0) {
                        result += '1';
                    }
                    else if (alphaPower === 1) {
                        result += 'a';
                    }
                    else {
                        result += "a^";
                        result += alphaPower;
                    }
                }
                if (degree != 0) {
                    if (degree === 1) {
                        result += 'x';
                    }
                    else {
                        result += "x^";
                        result += degree;
                    }
                }
            }
        }
        return result;
    };
    return GenericGFPoly;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.common.reedsolomon {*/
/**
 * <p>This class contains utility methods for performing mathematical operations over
the Galois Fields. Operations use a given primitive polynomial in calculations.</p>

<p>Throughout this package, elements of the GF are represented as an {\@code int}
for convenience and speed (but at the cost of memory).
</p>

\@author Sean Owen
\@author David Olivier
 */
var GenericGF = (function () {
    /**
     * Create a representation of GF(size) using the given primitive polynomial.
    
    \@param primitive irreducible polynomial whose coefficients are represented by
     the bits of an int, where the least-significant bit represents the constant
     coefficient
    \@param size the size of the field
    \@param b the factor b in the generator polynomial can be 0- or 1-based
     (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
     In most cases it should be 1, but for QR code it is 0.
     * @param {?} primitive
     * @param {?} size
     * @param {?} generatorBase
     */
    function GenericGF(primitive /*int*/, size /*int*/, generatorBase /*int*/) {
        this.primitive = primitive; /*int*/
        this.size = size; /*int*/
        this.generatorBase = generatorBase; /*int*/
        var expTable = new Int32Array(size);
        var x = 1;
        for (var i = 0; i < size; i++) {
            expTable[i] = x;
            x *= 2; // we're assuming the generator alpha is 2
            if (x >= size) {
                x ^= primitive;
                x &= size - 1;
            }
        }
        this.expTable = expTable;
        var logTable = new Int32Array(size);
        for (var i = 0; i < size - 1; i++) {
            logTable[expTable[i]] = i;
        }
        this.logTable = logTable;
        // logTable[0] == 0 but this should never be used
        this.zero = new GenericGFPoly(this, Int32Array.from([0]));
        this.one = new GenericGFPoly(this, Int32Array.from([1]));
    }
    /**
     * @return {?}
     */
    GenericGF.prototype.getZero = function () {
        return this.zero;
    };
    /**
     * @return {?}
     */
    GenericGF.prototype.getOne = function () {
        return this.one;
    };
    /**
     * @param {?} degree
     * @param {?} coefficient
     * @return {?} the monomial representing coefficient * x^degree
     */
    GenericGF.prototype.buildMonomial = function (degree /*int*/, coefficient /*int*/) {
        if (degree < 0) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        if (coefficient === 0) {
            return this.zero;
        }
        var /** @type {?} */ coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new GenericGFPoly(this, coefficients);
    };
    /**
     * Implements both addition and subtraction -- they are the same in GF(size).
    
    \@return sum/difference of a and b
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    GenericGF.addOrSubtract = function (a /*int*/, b /*int*/) {
        return a ^ b;
    };
    /**
     * @param {?} a
     * @return {?} 2 to the power of a in GF(size)
     */
    GenericGF.prototype.exp = function (a /*int*/) {
        return this.expTable[a];
    };
    /**
     * @param {?} a
     * @return {?} base 2 log of a in GF(size)
     */
    GenericGF.prototype.log = function (a /*int*/) {
        if (a === 0) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        return this.logTable[a];
    };
    /**
     * @param {?} a
     * @return {?} multiplicative inverse of a
     */
    GenericGF.prototype.inverse = function (a /*int*/) {
        if (a === 0) {
            throw new Exception(Exception.ArithmeticException);
        }
        return this.expTable[this.size - this.logTable[a] - 1];
    };
    /**
     * @param {?} a
     * @param {?} b
     * @return {?} product of a and b in GF(size)
     */
    GenericGF.prototype.multiply = function (a /*int*/, b /*int*/) {
        if (a === 0 || b === 0) {
            return 0;
        }
        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
    };
    /**
     * @return {?}
     */
    GenericGF.prototype.getSize = function () {
        return this.size;
    };
    /**
     * @return {?}
     */
    GenericGF.prototype.getGeneratorBase = function () {
        return this.generatorBase;
    };
    /**
     * @return {?}
     */
    GenericGF.prototype.toString = function () {
        return "GF(0x" + Integer.toHexString(this.primitive) + ',' + this.size + ')';
    };
    /**
     * @param {?} o
     * @return {?}
     */
    GenericGF.prototype.equals = function (o) {
        return o === this;
    };
    return GenericGF;
}());
GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1);
GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1);
GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1);
GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1);
GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011D, 256, 0);
GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012D, 256, 1);
GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.common.reedsolomon {*/
/**
 * <p>Implements Reed-Solomon decoding, as the name implies.</p>

<p>The algorithm will not be explained here, but the following references were helpful
in creating this implementation:</p>

<ul>
<li>Bruce Maggs.
<a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps">
"Decoding Reed-Solomon Codes"</a> (see discussion of Forney's Formula)</li>
<li>J.I. Hall. <a href="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">
"Chapter 5. Generalized Reed-Solomon Codes"</a>
(see discussion of Euclidean algorithm)</li>
</ul>

<p>Much credit is due to William Rucklidge since portions of this code are an indirect
port of his C++ Reed-Solomon implementation.</p>

\@author Sean Owen
\@author William Rucklidge
\@author sanfordsquires
 */
var ReedSolomonDecoder = (function () {
    /**
     * @param {?} field
     */
    function ReedSolomonDecoder(field) {
        this.field = field;
    }
    /**
     * <p>Decodes given set of received codewords, which include both data and error-correction
    codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,
    in the input.</p>
    
    \@param received data and error-correction codewords
    \@param twoS number of error-correction codewords available
    \@throws ReedSolomonException if decoding fails for any reason
     * @param {?} received
     * @param {?} twoS
     * @return {?}
     */
    ReedSolomonDecoder.prototype.decode = function (received, twoS /*int*/) {
        var /** @type {?} */ field = this.field;
        var /** @type {?} */ poly = new GenericGFPoly(field, received);
        var /** @type {?} */ syndromeCoefficients = new Int32Array(twoS);
        var /** @type {?} */ noError = true;
        for (var /** @type {?} */ i = 0; i < twoS; i++) {
            var /** @type {?} */ evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));
            syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;
            if (evalResult !== 0) {
                noError = false;
            }
        }
        if (noError) {
            return;
        }
        var /** @type {?} */ syndrome = new GenericGFPoly(field, syndromeCoefficients);
        var /** @type {?} */ sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
        var /** @type {?} */ sigma = sigmaOmega[0];
        var /** @type {?} */ omega = sigmaOmega[1];
        var /** @type {?} */ errorLocations = this.findErrorLocations(sigma);
        var /** @type {?} */ errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
        for (var /** @type {?} */ i = 0; i < errorLocations.length; i++) {
            var /** @type {?} */ position = received.length - 1 - field.log(errorLocations[i]);
            if (position < 0) {
                throw new Exception(Exception.ReedSolomonException, "Bad error location");
            }
            received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);
        }
    };
    /**
     * @param {?} a
     * @param {?} b
     * @param {?} R
     * @return {?}
     */
    ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R /*int*/) {
        // Assume a's degree is >= b's
        if (a.getDegree() < b.getDegree()) {
            var /** @type {?} */ temp = a;
            a = b;
            b = temp;
        }
        var /** @type {?} */ field = this.field;
        var /** @type {?} */ rLast = a;
        var /** @type {?} */ r = b;
        var /** @type {?} */ tLast = field.getZero();
        var /** @type {?} */ t = field.getOne();
        // Run Euclidean algorithm until r's degree is less than R/2
        while (r.getDegree() >= R / 2) {
            var /** @type {?} */ rLastLast = rLast;
            var /** @type {?} */ tLastLast = tLast;
            rLast = r;
            tLast = t;
            // Divide rLastLast by rLast, with quotient in q and remainder in r
            if (rLast.isZero()) {
                // Oops, Euclidean algorithm already terminated?
                throw new Exception(Exception.ReedSolomonException, "r_{i-1} was zero");
            }
            r = rLastLast;
            var /** @type {?} */ q = field.getZero();
            var /** @type {?} */ denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
            var /** @type {?} */ dltInverse = field.inverse(denominatorLeadingTerm);
            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
                var /** @type {?} */ degreeDiff = r.getDegree() - rLast.getDegree();
                var /** @type {?} */ scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
                q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
                r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
            }
            t = q.multiply(tLast).addOrSubtract(tLastLast);
            if (r.getDegree() >= rLast.getDegree()) {
                throw new Exception(Exception.IllegalStateException, "Division algorithm failed to reduce polynomial?");
            }
        }
        var /** @type {?} */ sigmaTildeAtZero = t.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
            throw new Exception(Exception.ReedSolomonException, "sigmaTilde(0) was zero");
        }
        var /** @type {?} */ inverse = field.inverse(sigmaTildeAtZero);
        var /** @type {?} */ sigma = t.multiplyScalar(inverse);
        var /** @type {?} */ omega = r.multiplyScalar(inverse);
        return [sigma, omega];
    };
    /**
     * @param {?} errorLocator
     * @return {?}
     */
    ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {
        // This is a direct application of Chien's search
        var /** @type {?} */ numErrors = errorLocator.getDegree();
        if (numErrors === 1) {
            return Int32Array.from([errorLocator.getCoefficient(1)]);
        }
        var /** @type {?} */ result = new Int32Array(numErrors);
        var /** @type {?} */ e = 0;
        var /** @type {?} */ field = this.field;
        for (var /** @type {?} */ i = 1; i < field.getSize() && e < numErrors; i++) {
            if (errorLocator.evaluateAt(i) === 0) {
                result[e] = field.inverse(i);
                e++;
            }
        }
        if (e !== numErrors) {
            throw new Exception(Exception.ReedSolomonException, "Error locator degree does not match number of roots");
        }
        return result;
    };
    /**
     * @param {?} errorEvaluator
     * @param {?} errorLocations
     * @return {?}
     */
    ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {
        // This is directly applying Forney's Formula
        var /** @type {?} */ s = errorLocations.length;
        var /** @type {?} */ result = new Int32Array(s);
        var /** @type {?} */ field = this.field;
        for (var /** @type {?} */ i = 0; i < s; i++) {
            var /** @type {?} */ xiInverse = field.inverse(errorLocations[i]);
            var /** @type {?} */ denominator = 1;
            for (var /** @type {?} */ j = 0; j < s; j++) {
                if (i !== j) {
                    //denominator = field.multiply(denominator,
                    //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))
                    // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.
                    // Below is a funny-looking workaround from Steven Parkes
                    var /** @type {?} */ term = field.multiply(errorLocations[j], xiInverse);
                    var /** @type {?} */ termPlus1 = (term & 0x1) == 0 ? term | 1 : term & ~1;
                    denominator = field.multiply(denominator, termPlus1);
                }
            }
            result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
            if (field.getGeneratorBase() != 0) {
                result[i] = field.multiply(result[i], xiInverse);
            }
        }
        return result;
    };
    return ReedSolomonDecoder;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.qrcode.decoder {*/
/**
 * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels
defined by the QR code standard.</p>

\@author Sean Owen
 */
var ErrorCorrectionLevel = (function () {
    /**
     * @param {?} value
     * @param {?} stringValue
     * @param {?} bits
     */
    function ErrorCorrectionLevel(value, stringValue, bits /*int*/) {
        this.value = value;
        this.stringValue = stringValue;
        this.bits = bits; /*int*/
        ErrorCorrectionLevel.FOR_BITS.set(bits, this);
        ErrorCorrectionLevel.FOR_VALUE.set(value, this);
    }
    /**
     * @return {?}
     */
    ErrorCorrectionLevel.prototype.getValue = function () {
        return this.value;
    };
    /**
     * @return {?}
     */
    ErrorCorrectionLevel.prototype.getBits = function () {
        return this.bits;
    };
    /**
     * @param {?} s
     * @return {?}
     */
    ErrorCorrectionLevel.fromString = function (s) {
        switch (s) {
            case "L": return ErrorCorrectionLevel.L;
            case "M": return ErrorCorrectionLevel.M;
            case "Q": return ErrorCorrectionLevel.Q;
            case "H": return ErrorCorrectionLevel.H;
            default: throw new Exception(Exception.ArgumentException, s + "not available");
        }
    };
    /**
     * @return {?}
     */
    ErrorCorrectionLevel.prototype.toString = function () {
        return this.stringValue;
    };
    /**
     * @param {?} o
     * @return {?}
     */
    ErrorCorrectionLevel.prototype.equals = function (o) {
        if (!(o instanceof ErrorCorrectionLevel)) {
            return false;
        }
        var /** @type {?} */ other = (o);
        return this.value === other.value;
    };
    /**
     * @param {?} bits int containing the two bits encoding a QR Code's error correction level
     * @return {?}
     */
    ErrorCorrectionLevel.forBits = function (bits /*int*/) {
        if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        return ErrorCorrectionLevel.FOR_BITS.get(bits);
    };
    return ErrorCorrectionLevel;
}());
ErrorCorrectionLevel.FOR_BITS = new Map();
ErrorCorrectionLevel.FOR_VALUE = new Map();
/**
 * L = ~7% correction
 */
ErrorCorrectionLevel.L = new ErrorCorrectionLevel(0 /* L */, "L", 0x01);
/**
 * M = ~15% correction
 */
ErrorCorrectionLevel.M = new ErrorCorrectionLevel(1 /* M */, "M", 0x00);
/**
 * Q = ~25% correction
 */
ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(2 /* Q */, "Q", 0x03);
/**
 * H = ~30% correction
 */
ErrorCorrectionLevel.H = new ErrorCorrectionLevel(3 /* H */, "H", 0x02);

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.qrcode.decoder {*/
/**
 * <p>Encapsulates a QR Code's format information, including the data mask used and
error correction level.</p>

\@author Sean Owen
\@see DataMask
\@see ErrorCorrectionLevel
 */
var FormatInformation = (function () {
    /**
     * @param {?} formatInfo
     */
    function FormatInformation(formatInfo /*int*/) {
        // Bits 3,4
        this.errorCorrectionLevel = ErrorCorrectionLevel.forBits((formatInfo >> 3) & 0x03);
        // Bottom 3 bits
        this.dataMask = (formatInfo & 0x07);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    FormatInformation.numBitsDiffering = function (a /*int*/, b /*int*/) {
        return Integer.bitCount(a ^ b);
    };
    /**
     * @param {?} maskedFormatInfo1 format info indicator, with mask still applied
     * @param {?} maskedFormatInfo2
     * @return {?}
     */
    FormatInformation.decodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {
        var /** @type {?} */ formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
        if (formatInfo !== null) {
            return formatInfo;
        }
        // Should return null, but, some QR codes apparently
        // do not mask this info. Try again by actually masking the pattern
        // first
        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
    };
    /**
     * @param {?} maskedFormatInfo1
     * @param {?} maskedFormatInfo2
     * @return {?}
     */
    FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {
        // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing
        var /** @type {?} */ bestDifference = Number.MAX_SAFE_INTEGER;
        var /** @type {?} */ bestFormatInfo = 0;
        for (var _i = 0, _a = FormatInformation.FORMAT_INFO_DECODE_LOOKUP; _i < _a.length; _i++) {
            var decodeInfo = _a[_i];
            var /** @type {?} */ targetInfo = decodeInfo[0];
            if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
                // Found an exact match
                return new FormatInformation(decodeInfo[1]);
            }
            var /** @type {?} */ bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
            if (bitsDifference < bestDifference) {
                bestFormatInfo = decodeInfo[1];
                bestDifference = bitsDifference;
            }
            if (maskedFormatInfo1 != maskedFormatInfo2) {
                // also try the other option
                bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
                if (bitsDifference < bestDifference) {
                    bestFormatInfo = decodeInfo[1];
                    bestDifference = bitsDifference;
                }
            }
        }
        // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits
        // differing means we found a match
        if (bestDifference <= 3) {
            return new FormatInformation(bestFormatInfo);
        }
        return null;
    };
    /**
     * @return {?}
     */
    FormatInformation.prototype.getErrorCorrectionLevel = function () {
        return this.errorCorrectionLevel;
    };
    /**
     * @return {?}
     */
    FormatInformation.prototype.getDataMask = function () {
        return this.dataMask;
    };
    /**
     * @return {?}
     */
    FormatInformation.prototype.hashCode = function () {
        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;
    };
    /**
     * @param {?} o
     * @return {?}
     */
    FormatInformation.prototype.equals = function (o) {
        if (!(o instanceof FormatInformation)) {
            return false;
        }
        var /** @type {?} */ other = (o);
        return this.errorCorrectionLevel === other.errorCorrectionLevel &&
            this.dataMask === other.dataMask;
    };
    return FormatInformation;
}());
FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;
/**
 * See ISO 18004:2006, Annex C, Table C.1
 */
FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
    Int32Array.from([0x5412, 0x00]),
    Int32Array.from([0x5125, 0x01]),
    Int32Array.from([0x5E7C, 0x02]),
    Int32Array.from([0x5B4B, 0x03]),
    Int32Array.from([0x45F9, 0x04]),
    Int32Array.from([0x40CE, 0x05]),
    Int32Array.from([0x4F97, 0x06]),
    Int32Array.from([0x4AA0, 0x07]),
    Int32Array.from([0x77C4, 0x08]),
    Int32Array.from([0x72F3, 0x09]),
    Int32Array.from([0x7DAA, 0x0A]),
    Int32Array.from([0x789D, 0x0B]),
    Int32Array.from([0x662F, 0x0C]),
    Int32Array.from([0x6318, 0x0D]),
    Int32Array.from([0x6C41, 0x0E]),
    Int32Array.from([0x6976, 0x0F]),
    Int32Array.from([0x1689, 0x10]),
    Int32Array.from([0x13BE, 0x11]),
    Int32Array.from([0x1CE7, 0x12]),
    Int32Array.from([0x19D0, 0x13]),
    Int32Array.from([0x0762, 0x14]),
    Int32Array.from([0x0255, 0x15]),
    Int32Array.from([0x0D0C, 0x16]),
    Int32Array.from([0x083B, 0x17]),
    Int32Array.from([0x355F, 0x18]),
    Int32Array.from([0x3068, 0x19]),
    Int32Array.from([0x3F31, 0x1A]),
    Int32Array.from([0x3A06, 0x1B]),
    Int32Array.from([0x24B4, 0x1C]),
    Int32Array.from([0x2183, 0x1D]),
    Int32Array.from([0x2EDA, 0x1E]),
    Int32Array.from([0x2BED, 0x1F]),
];

/**
 * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
use blocks of differing sizes within one version, so, this encapsulates the parameters for
each set of blocks. It also holds the number of error-correction codewords per block since it
will be the same across all blocks within one version.</p>
 */
var ECBlocks = (function () {
    /**
     * @param {?} ecCodewordsPerBlock
     * @param {...?} ecBlocks
     */
    function ECBlocks(ecCodewordsPerBlock /*int*/) {
        var ecBlocks = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            ecBlocks[_i - 1] = arguments[_i];
        }
        this.ecCodewordsPerBlock = ecCodewordsPerBlock; /*int*/
        this.ecBlocks = ecBlocks;
    }
    /**
     * @return {?}
     */
    ECBlocks.prototype.getECCodewordsPerBlock = function () {
        return this.ecCodewordsPerBlock;
    };
    /**
     * @return {?}
     */
    ECBlocks.prototype.getNumBlocks = function () {
        var /** @type {?} */ total = 0;
        var /** @type {?} */ ecBlocks = this.ecBlocks;
        for (var _i = 0, ecBlocks_1 = ecBlocks; _i < ecBlocks_1.length; _i++) {
            var ecBlock = ecBlocks_1[_i];
            total += ecBlock.getCount();
        }
        return total;
    };
    /**
     * @return {?}
     */
    ECBlocks.prototype.getTotalECCodewords = function () {
        return this.ecCodewordsPerBlock * this.getNumBlocks();
    };
    /**
     * @return {?}
     */
    ECBlocks.prototype.getECBlocks = function () {
        return this.ecBlocks;
    };
    return ECBlocks;
}());

/**
 * <p>Encapsulates the parameters for one error-correction block in one symbol version.
This includes the number of data codewords, and the number of times a block with these
parameters is used consecutively in the QR code version's format.</p>
 */
var ECB = (function () {
    /**
     * @param {?} count
     * @param {?} dataCodewords
     */
    function ECB(count /*int*/, dataCodewords /*int*/) {
        this.count = count;
        this.dataCodewords = dataCodewords;
    }
    /**
     * @return {?}
     */
    ECB.prototype.getCount = function () {
        return this.count;
    };
    /**
     * @return {?}
     */
    ECB.prototype.getDataCodewords = function () {
        return this.dataCodewords;
    };
    return ECB;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.qrcode.decoder {*/
/**
 * See ISO 18004:2006 Annex D

\@author Sean Owen
 */
var Version = (function () {
    /**
     * @param {?} versionNumber
     * @param {?} alignmentPatternCenters
     * @param {...?} ecBlocks
     */
    function Version(versionNumber /*int*/, alignmentPatternCenters) {
        var ecBlocks = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            ecBlocks[_i - 2] = arguments[_i];
        }
        this.versionNumber = versionNumber; /*int*/
        this.alignmentPatternCenters = alignmentPatternCenters;
        this.ecBlocks = ecBlocks;
        var total = 0;
        var ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
        var ecbArray = ecBlocks[0].getECBlocks();
        for (var _a = 0, ecbArray_1 = ecbArray; _a < ecbArray_1.length; _a++) {
            var ecBlock = ecbArray_1[_a];
            total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
        }
        this.totalCodewords = total;
    }
    /**
     * @return {?}
     */
    Version.prototype.getVersionNumber = function () {
        return this.versionNumber;
    };
    /**
     * @return {?}
     */
    Version.prototype.getAlignmentPatternCenters = function () {
        return this.alignmentPatternCenters;
    };
    /**
     * @return {?}
     */
    Version.prototype.getTotalCodewords = function () {
        return this.totalCodewords;
    };
    /**
     * @return {?}
     */
    Version.prototype.getDimensionForVersion = function () {
        return 17 + 4 * this.versionNumber;
    };
    /**
     * @param {?} ecLevel
     * @return {?}
     */
    Version.prototype.getECBlocksForLevel = function (ecLevel) {
        return this.ecBlocks[ecLevel.getValue()];
        // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)
        // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number
    };
    /**
     * <p>Deduces version information purely from QR Code dimensions.</p>
    
    \@param dimension dimension in modules
    \@return Version for a QR Code of that dimension
    \@throws FormatException if dimension is not 1 mod 4
     * @param {?} dimension
     * @return {?}
     */
    Version.getProvisionalVersionForDimension = function (dimension /*int*/) {
        if (dimension % 4 != 1) {
            throw new Exception(Exception.FormatException);
        }
        try {
            return this.getVersionForNumber((dimension - 17) / 4);
        }
        catch (ignored /*: IllegalArgumentException*/) {
            throw new Exception(Exception.FormatException);
        }
    };
    /**
     * @param {?} versionNumber
     * @return {?}
     */
    Version.getVersionForNumber = function (versionNumber /*int*/) {
        if (versionNumber < 1 || versionNumber > 40) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        return Version.VERSIONS[versionNumber - 1];
    };
    /**
     * @param {?} versionBits
     * @return {?}
     */
    Version.decodeVersionInformation = function (versionBits /*int*/) {
        var /** @type {?} */ bestDifference = Number.MAX_SAFE_INTEGER;
        var /** @type {?} */ bestVersion = 0;
        for (var /** @type {?} */ i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {
            var /** @type {?} */ targetVersion = Version.VERSION_DECODE_INFO[i];
            // Do the version info bits match exactly? done.
            if (targetVersion === versionBits) {
                return Version.getVersionForNumber(i + 7);
            }
            // Otherwise see if this is the closest to a real version info bit string
            // we have seen so far
            var /** @type {?} */ bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
            if (bitsDifference < bestDifference) {
                bestVersion = i + 7;
                bestDifference = bitsDifference;
            }
        }
        // We can tolerate up to 3 bits of error since no two version info codewords will
        // differ in less than 8 bits.
        if (bestDifference <= 3) {
            return Version.getVersionForNumber(bestVersion);
        }
        // If we didn't find a close enough match, fail
        return null;
    };
    /**
     * See ISO 18004:2006 Annex E
     * @return {?}
     */
    Version.prototype.buildFunctionPattern = function () {
        var /** @type {?} */ dimension = this.getDimensionForVersion();
        var /** @type {?} */ bitMatrix = new BitMatrix(dimension);
        // Top left finder pattern + separator + format
        bitMatrix.setRegion(0, 0, 9, 9);
        // Top right finder pattern + separator + format
        bitMatrix.setRegion(dimension - 8, 0, 8, 9);
        // Bottom left finder pattern + separator + format
        bitMatrix.setRegion(0, dimension - 8, 9, 8);
        // Alignment patterns
        var /** @type {?} */ max = this.alignmentPatternCenters.length;
        for (var /** @type {?} */ x = 0; x < max; x++) {
            var /** @type {?} */ i = this.alignmentPatternCenters[x] - 2;
            for (var /** @type {?} */ y = 0; y < max; y++) {
                if ((x == 0 && (y == 0 || y == max - 1)) || (x == max - 1 && y == 0)) {
                    // No alignment patterns near the three finder patterns
                    continue;
                }
                bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
            }
        }
        // Vertical timing pattern
        bitMatrix.setRegion(6, 9, 1, dimension - 17);
        // Horizontal timing pattern
        bitMatrix.setRegion(9, 6, dimension - 17, 1);
        if (this.versionNumber > 6) {
            // Version info, top right
            bitMatrix.setRegion(dimension - 11, 0, 3, 6);
            // Version info, bottom left
            bitMatrix.setRegion(0, dimension - 11, 6, 3);
        }
        return bitMatrix;
    };
    /**
     * @return {?}
     */
    Version.prototype.toString = function () {
        return "" + this.versionNumber;
    };
    return Version;
}());
/**
 * See ISO 18004:2006 Annex D.
Element i represents the raw version bits that specify version i + 7
 */
Version.VERSION_DECODE_INFO = Int32Array.from([
    0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6,
    0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78,
    0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683,
    0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,
    0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,
    0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B,
    0x2542E, 0x26A64, 0x27541, 0x28C69
]);
/**
 * See ISO 18004:2006 6.5.1 Table 9
 */
Version.VERSIONS = [
    new Version(1, new Int32Array(0), new ECBlocks(7, new ECB(1, 19)), new ECBlocks(10, new ECB(1, 16)), new ECBlocks(13, new ECB(1, 13)), new ECBlocks(17, new ECB(1, 9))),
    new Version(2, Int32Array.from([6, 18]), new ECBlocks(10, new ECB(1, 34)), new ECBlocks(16, new ECB(1, 28)), new ECBlocks(22, new ECB(1, 22)), new ECBlocks(28, new ECB(1, 16))),
    new Version(3, Int32Array.from([6, 22]), new ECBlocks(15, new ECB(1, 55)), new ECBlocks(26, new ECB(1, 44)), new ECBlocks(18, new ECB(2, 17)), new ECBlocks(22, new ECB(2, 13))),
    new Version(4, Int32Array.from([6, 26]), new ECBlocks(20, new ECB(1, 80)), new ECBlocks(18, new ECB(2, 32)), new ECBlocks(26, new ECB(2, 24)), new ECBlocks(16, new ECB(4, 9))),
    new Version(5, Int32Array.from([6, 30]), new ECBlocks(26, new ECB(1, 108)), new ECBlocks(24, new ECB(2, 43)), new ECBlocks(18, new ECB(2, 15), new ECB(2, 16)), new ECBlocks(22, new ECB(2, 11), new ECB(2, 12))),
    new Version(6, Int32Array.from([6, 34]), new ECBlocks(18, new ECB(2, 68)), new ECBlocks(16, new ECB(4, 27)), new ECBlocks(24, new ECB(4, 19)), new ECBlocks(28, new ECB(4, 15))),
    new Version(7, Int32Array.from([6, 22, 38]), new ECBlocks(20, new ECB(2, 78)), new ECBlocks(18, new ECB(4, 31)), new ECBlocks(18, new ECB(2, 14), new ECB(4, 15)), new ECBlocks(26, new ECB(4, 13), new ECB(1, 14))),
    new Version(8, Int32Array.from([6, 24, 42]), new ECBlocks(24, new ECB(2, 97)), new ECBlocks(22, new ECB(2, 38), new ECB(2, 39)), new ECBlocks(22, new ECB(4, 18), new ECB(2, 19)), new ECBlocks(26, new ECB(4, 14), new ECB(2, 15))),
    new Version(9, Int32Array.from([6, 26, 46]), new ECBlocks(30, new ECB(2, 116)), new ECBlocks(22, new ECB(3, 36), new ECB(2, 37)), new ECBlocks(20, new ECB(4, 16), new ECB(4, 17)), new ECBlocks(24, new ECB(4, 12), new ECB(4, 13))),
    new Version(10, Int32Array.from([6, 28, 50]), new ECBlocks(18, new ECB(2, 68), new ECB(2, 69)), new ECBlocks(26, new ECB(4, 43), new ECB(1, 44)), new ECBlocks(24, new ECB(6, 19), new ECB(2, 20)), new ECBlocks(28, new ECB(6, 15), new ECB(2, 16))),
    new Version(11, Int32Array.from([6, 30, 54]), new ECBlocks(20, new ECB(4, 81)), new ECBlocks(30, new ECB(1, 50), new ECB(4, 51)), new ECBlocks(28, new ECB(4, 22), new ECB(4, 23)), new ECBlocks(24, new ECB(3, 12), new ECB(8, 13))),
    new Version(12, Int32Array.from([6, 32, 58]), new ECBlocks(24, new ECB(2, 92), new ECB(2, 93)), new ECBlocks(22, new ECB(6, 36), new ECB(2, 37)), new ECBlocks(26, new ECB(4, 20), new ECB(6, 21)), new ECBlocks(28, new ECB(7, 14), new ECB(4, 15))),
    new Version(13, Int32Array.from([6, 34, 62]), new ECBlocks(26, new ECB(4, 107)), new ECBlocks(22, new ECB(8, 37), new ECB(1, 38)), new ECBlocks(24, new ECB(8, 20), new ECB(4, 21)), new ECBlocks(22, new ECB(12, 11), new ECB(4, 12))),
    new Version(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks(30, new ECB(3, 115), new ECB(1, 116)), new ECBlocks(24, new ECB(4, 40), new ECB(5, 41)), new ECBlocks(20, new ECB(11, 16), new ECB(5, 17)), new ECBlocks(24, new ECB(11, 12), new ECB(5, 13))),
    new Version(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks(22, new ECB(5, 87), new ECB(1, 88)), new ECBlocks(24, new ECB(5, 41), new ECB(5, 42)), new ECBlocks(30, new ECB(5, 24), new ECB(7, 25)), new ECBlocks(24, new ECB(11, 12), new ECB(7, 13))),
    new Version(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks(24, new ECB(5, 98), new ECB(1, 99)), new ECBlocks(28, new ECB(7, 45), new ECB(3, 46)), new ECBlocks(24, new ECB(15, 19), new ECB(2, 20)), new ECBlocks(30, new ECB(3, 15), new ECB(13, 16))),
    new Version(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks(28, new ECB(1, 107), new ECB(5, 108)), new ECBlocks(28, new ECB(10, 46), new ECB(1, 47)), new ECBlocks(28, new ECB(1, 22), new ECB(15, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(17, 15))),
    new Version(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks(30, new ECB(5, 120), new ECB(1, 121)), new ECBlocks(26, new ECB(9, 43), new ECB(4, 44)), new ECBlocks(28, new ECB(17, 22), new ECB(1, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(19, 15))),
    new Version(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks(28, new ECB(3, 113), new ECB(4, 114)), new ECBlocks(26, new ECB(3, 44), new ECB(11, 45)), new ECBlocks(26, new ECB(17, 21), new ECB(4, 22)), new ECBlocks(26, new ECB(9, 13), new ECB(16, 14))),
    new Version(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks(28, new ECB(3, 107), new ECB(5, 108)), new ECBlocks(26, new ECB(3, 41), new ECB(13, 42)), new ECBlocks(30, new ECB(15, 24), new ECB(5, 25)), new ECBlocks(28, new ECB(15, 15), new ECB(10, 16))),
    new Version(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks(28, new ECB(4, 116), new ECB(4, 117)), new ECBlocks(26, new ECB(17, 42)), new ECBlocks(28, new ECB(17, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(19, 16), new ECB(6, 17))),
    new Version(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks(28, new ECB(2, 111), new ECB(7, 112)), new ECBlocks(28, new ECB(17, 46)), new ECBlocks(30, new ECB(7, 24), new ECB(16, 25)), new ECBlocks(24, new ECB(34, 13))),
    new Version(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks(30, new ECB(4, 121), new ECB(5, 122)), new ECBlocks(28, new ECB(4, 47), new ECB(14, 48)), new ECBlocks(30, new ECB(11, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(16, 15), new ECB(14, 16))),
    new Version(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks(30, new ECB(6, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(6, 45), new ECB(14, 46)), new ECBlocks(30, new ECB(11, 24), new ECB(16, 25)), new ECBlocks(30, new ECB(30, 16), new ECB(2, 17))),
    new Version(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks(26, new ECB(8, 106), new ECB(4, 107)), new ECBlocks(28, new ECB(8, 47), new ECB(13, 48)), new ECBlocks(30, new ECB(7, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(13, 16))),
    new Version(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks(28, new ECB(10, 114), new ECB(2, 115)), new ECBlocks(28, new ECB(19, 46), new ECB(4, 47)), new ECBlocks(28, new ECB(28, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(33, 16), new ECB(4, 17))),
    new Version(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks(30, new ECB(8, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(22, 45), new ECB(3, 46)), new ECBlocks(30, new ECB(8, 23), new ECB(26, 24)), new ECBlocks(30, new ECB(12, 15), new ECB(28, 16))),
    new Version(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks(30, new ECB(3, 117), new ECB(10, 118)), new ECBlocks(28, new ECB(3, 45), new ECB(23, 46)), new ECBlocks(30, new ECB(4, 24), new ECB(31, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(31, 16))),
    new Version(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks(30, new ECB(7, 116), new ECB(7, 117)), new ECBlocks(28, new ECB(21, 45), new ECB(7, 46)), new ECBlocks(30, new ECB(1, 23), new ECB(37, 24)), new ECBlocks(30, new ECB(19, 15), new ECB(26, 16))),
    new Version(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks(30, new ECB(5, 115), new ECB(10, 116)), new ECBlocks(28, new ECB(19, 47), new ECB(10, 48)), new ECBlocks(30, new ECB(15, 24), new ECB(25, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(25, 16))),
    new Version(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks(30, new ECB(13, 115), new ECB(3, 116)), new ECBlocks(28, new ECB(2, 46), new ECB(29, 47)), new ECBlocks(30, new ECB(42, 24), new ECB(1, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(28, 16))),
    new Version(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks(30, new ECB(17, 115)), new ECBlocks(28, new ECB(10, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(10, 24), new ECB(35, 25)), new ECBlocks(30, new ECB(19, 15), new ECB(35, 16))),
    new Version(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks(30, new ECB(17, 115), new ECB(1, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(21, 47)), new ECBlocks(30, new ECB(29, 24), new ECB(19, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(46, 16))),
    new Version(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks(30, new ECB(13, 115), new ECB(6, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(44, 24), new ECB(7, 25)), new ECBlocks(30, new ECB(59, 16), new ECB(1, 17))),
    new Version(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks(30, new ECB(12, 121), new ECB(7, 122)), new ECBlocks(28, new ECB(12, 47), new ECB(26, 48)), new ECBlocks(30, new ECB(39, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(41, 16))),
    new Version(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks(30, new ECB(6, 121), new ECB(14, 122)), new ECBlocks(28, new ECB(6, 47), new ECB(34, 48)), new ECBlocks(30, new ECB(46, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(2, 15), new ECB(64, 16))),
    new Version(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks(30, new ECB(17, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(29, 46), new ECB(14, 47)), new ECBlocks(30, new ECB(49, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(24, 15), new ECB(46, 16))),
    new Version(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks(30, new ECB(4, 122), new ECB(18, 123)), new ECBlocks(28, new ECB(13, 46), new ECB(32, 47)), new ECBlocks(30, new ECB(48, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(42, 15), new ECB(32, 16))),
    new Version(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks(30, new ECB(20, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(40, 47), new ECB(7, 48)), new ECBlocks(30, new ECB(43, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(10, 15), new ECB(67, 16))),
    new Version(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks(30, new ECB(19, 118), new ECB(6, 119)), new ECBlocks(28, new ECB(18, 47), new ECB(31, 48)), new ECBlocks(30, new ECB(34, 24), new ECB(34, 25)), new ECBlocks(30, new ECB(20, 15), new ECB(61, 16)))
];

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations
of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,
including areas used for finder patterns, timing patterns, etc. These areas should be unused
after the point they are unmasked anyway.</p>

<p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position
and j is row position. In fact, as the text says, i is row position and j is column position.</p>

\@author Sean Owen
 */
var DataMask = (function () {
    /**
     * @param {?} value
     * @param {?} isMasked
     */
    function DataMask(value, isMasked) {
        this.value = value;
        this.isMasked = isMasked;
    }
    /**
     * <p>Implementations of this method reverse the data masking process applied to a QR Code and
    make its bits ready to read.</p>
    
    \@param bits representation of QR Code bits
    \@param dimension dimension of QR Code, represented by bits, being unmasked
     * @param {?} bits
     * @param {?} dimension
     * @return {?}
     */
    DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {
        for (var /** @type {?} */ i = 0; i < dimension; i++) {
            for (var /** @type {?} */ j = 0; j < dimension; j++) {
                if (this.isMasked(i, j)) {
                    bits.flip(j, i);
                }
            }
        }
    };
    return DataMask;
}());
DataMask.values = new Map([
    /**
     * 000: mask bits for which (x + y) mod 2 == 0
     */
    [0 /* DATA_MASK_000 */, new DataMask(0 /* DATA_MASK_000 */, function (i /*int*/, j /*int*/) { return ((i + j) & 0x01) === 0; })],
    /**
     * 001: mask bits for which x mod 2 == 0
     */
    [1 /* DATA_MASK_001 */, new DataMask(1 /* DATA_MASK_001 */, function (i /*int*/, j /*int*/) { return (i & 0x01) === 0; })],
    /**
     * 010: mask bits for which y mod 3 == 0
     */
    [2 /* DATA_MASK_010 */, new DataMask(2 /* DATA_MASK_010 */, function (i /*int*/, j /*int*/) { return j % 3 === 0; })],
    /**
     * 011: mask bits for which (x + y) mod 3 == 0
     */
    [3 /* DATA_MASK_011 */, new DataMask(3 /* DATA_MASK_011 */, function (i /*int*/, j /*int*/) { return (i + j) % 3 === 0; })],
    /**
     * 100: mask bits for which (x/2 + y/3) mod 2 == 0
     */
    [4 /* DATA_MASK_100 */, new DataMask(4 /* DATA_MASK_100 */, function (i /*int*/, j /*int*/) { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],
    /**
     * 101: mask bits for which xy mod 2 + xy mod 3 == 0
     * equivalently, such that xy mod 6 == 0
     */
    [5 /* DATA_MASK_101 */, new DataMask(5 /* DATA_MASK_101 */, function (i /*int*/, j /*int*/) { return (i * j) % 6 === 0; })],
    /**
     * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0
     * equivalently, such that xy mod 6 < 3
     */
    [6 /* DATA_MASK_110 */, new DataMask(6 /* DATA_MASK_110 */, function (i /*int*/, j /*int*/) { return ((i * j) % 6) < 3; })],
    /**
     * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0
     * equivalently, such that (x + y + xy mod 3) mod 2 == 0
     */
    [7 /* DATA_MASK_111 */, new DataMask(7 /* DATA_MASK_111 */, function (i /*int*/, j /*int*/) { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],
]);

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @author Sean Owen
 */
var BitMatrixParser = (function () {
    /**
     * @param {?} bitMatrix {\@link BitMatrix} to parse
     */
    function BitMatrixParser(bitMatrix) {
        var dimension = bitMatrix.getHeight();
        if (dimension < 21 || (dimension & 0x03) != 1) {
            throw new Exception(Exception.FormatException);
        }
        this.bitMatrix = bitMatrix;
    }
    /**
     * <p>Reads format information from one of its two locations within the QR Code.</p>
    
    \@return {\@link FormatInformation} encapsulating the QR Code's format info
    \@throws FormatException if both format information locations cannot be parsed as
    the valid encoding of format information
     * @return {?}
     */
    BitMatrixParser.prototype.readFormatInformation = function () {
        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {
            return this.parsedFormatInfo;
        }
        // Read top-left format info bits
        var /** @type {?} */ formatInfoBits1 = 0;
        for (var /** @type {?} */ i = 0; i < 6; i++) {
            formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);
        }
        // .. and skip a bit in the timing pattern ...
        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
        // .. and skip a bit in the timing pattern ...
        for (var /** @type {?} */ j = 5; j >= 0; j--) {
            formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
        }
        // Read the top-right/bottom-left pattern too
        var /** @type {?} */ dimension = this.bitMatrix.getHeight();
        var /** @type {?} */ formatInfoBits2 = 0;
        var /** @type {?} */ jMin = dimension - 7;
        for (var /** @type {?} */ j = dimension - 1; j >= jMin; j--) {
            formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
        }
        for (var /** @type {?} */ i = dimension - 8; i < dimension; i++) {
            formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);
        }
        this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
        if (this.parsedFormatInfo !== null) {
            return this.parsedFormatInfo;
        }
        throw new Exception(Exception.FormatException);
    };
    /**
     * <p>Reads version information from one of its two locations within the QR Code.</p>
    
    \@return {\@link Version} encapsulating the QR Code's version
    \@throws FormatException if both version information locations cannot be parsed as
    the valid encoding of version information
     * @return {?}
     */
    BitMatrixParser.prototype.readVersion = function () {
        if (this.parsedVersion !== null && this.parsedVersion !== undefined) {
            return this.parsedVersion;
        }
        var /** @type {?} */ dimension = this.bitMatrix.getHeight();
        var /** @type {?} */ provisionalVersion = Math.floor((dimension - 17) / 4);
        if (provisionalVersion <= 6) {
            return Version.getVersionForNumber(provisionalVersion);
        }
        // Read top-right version info: 3 wide by 6 tall
        var /** @type {?} */ versionBits = 0;
        var /** @type {?} */ ijMin = dimension - 11;
        for (var /** @type {?} */ j = 5; j >= 0; j--) {
            for (var /** @type {?} */ i = dimension - 9; i >= ijMin; i--) {
                versionBits = this.copyBit(i, j, versionBits);
            }
        }
        var /** @type {?} */ theParsedVersion = Version.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() == dimension) {
            this.parsedVersion = theParsedVersion;
            return theParsedVersion;
        }
        // Hmm, failed. Try bottom left: 6 wide by 3 tall
        versionBits = 0;
        for (var /** @type {?} */ i = 5; i >= 0; i--) {
            for (var /** @type {?} */ j = dimension - 9; j >= ijMin; j--) {
                versionBits = this.copyBit(i, j, versionBits);
            }
        }
        theParsedVersion = Version.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() == dimension) {
            this.parsedVersion = theParsedVersion;
            return theParsedVersion;
        }
        throw new Exception(Exception.FormatException);
    };
    /**
     * @param {?} i
     * @param {?} j
     * @param {?} versionBits
     * @return {?}
     */
    BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {
        var /** @type {?} */ bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);
        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;
    };
    /**
     * <p>Reads the bits in the {\@link BitMatrix} representing the finder pattern in the
    correct order in order to reconstruct the codewords bytes contained within the
    QR Code.</p>
    
    \@return bytes encoded within the QR Code
    \@throws FormatException if the exact number of bytes expected is not read
     * @return {?}
     */
    BitMatrixParser.prototype.readCodewords = function () {
        var /** @type {?} */ formatInfo = this.readFormatInformation();
        var /** @type {?} */ version = this.readVersion();
        // Get the data mask for the format used in this QR Code. This will exclude
        // some bits from reading as we wind through the bit matrix.
        var /** @type {?} */ dataMask = DataMask.values.get(formatInfo.getDataMask());
        var /** @type {?} */ dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
        var /** @type {?} */ functionPattern = version.buildFunctionPattern();
        var /** @type {?} */ readingUp = true;
        var /** @type {?} */ result = new Uint8Array(version.getTotalCodewords());
        var /** @type {?} */ resultOffset = 0;
        var /** @type {?} */ currentByte = 0;
        var /** @type {?} */ bitsRead = 0;
        // Read columns in pairs, from right to left
        for (var /** @type {?} */ j = dimension - 1; j > 0; j -= 2) {
            if (j == 6) {
                // Skip whole column with vertical alignment pattern
                // saves time and makes the other code proceed more cleanly
                j--;
            }
            // Read alternatingly from bottom to top then top to bottom
            for (var /** @type {?} */ count = 0; count < dimension; count++) {
                var /** @type {?} */ i = readingUp ? dimension - 1 - count : count;
                for (var /** @type {?} */ col = 0; col < 2; col++) {
                    // Ignore bits covered by the function pattern
                    if (!functionPattern.get(j - col, i)) {
                        // Read a bit
                        bitsRead++;
                        currentByte <<= 1;
                        if (this.bitMatrix.get(j - col, i)) {
                            currentByte |= 1;
                        }
                        // If we've made a whole byte, save it off
                        if (bitsRead == 8) {
                            result[resultOffset++] = currentByte;
                            bitsRead = 0;
                            currentByte = 0;
                        }
                    }
                }
            }
            readingUp = !readingUp; //readingUp ^= true; // readingUp = !readingUp; // switch directions
        }
        if (resultOffset != version.getTotalCodewords()) {
            throw new Exception(Exception.FormatException);
        }
        return result;
    };
    /**
     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.
     * @return {?}
     */
    BitMatrixParser.prototype.remask = function () {
        if (this.parsedFormatInfo === null) {
            return; // We have no format information, and have no data mask
        }
        var /** @type {?} */ dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];
        var /** @type {?} */ dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
    };
    /**
     * Prepare the parser for a mirrored operation.
    This flag has effect only on the {\@link #readFormatInformation()} and the
    {\@link #readVersion()}. Before proceeding with {\@link #readCodewords()} the
    {\@link #mirror()} method should be called.
    
    \@param mirror Whether to read version and format information mirrored.
     * @param {?} isMirror
     * @return {?}
     */
    BitMatrixParser.prototype.setMirror = function (isMirror) {
        this.parsedVersion = null;
        this.parsedFormatInfo = null;
        this.isMirror = isMirror;
    };
    /**
     * Mirror the bit matrix in order to attempt a second reading.
     * @return {?}
     */
    BitMatrixParser.prototype.mirror = function () {
        var /** @type {?} */ bitMatrix = this.bitMatrix;
        for (var /** @type {?} */ x = 0, /** @type {?} */ width = bitMatrix.getWidth(); x < width; x++) {
            for (var /** @type {?} */ y = x + 1, /** @type {?} */ height = bitMatrix.getHeight(); y < height; y++) {
                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {
                    bitMatrix.flip(y, x);
                    bitMatrix.flip(x, y);
                }
            }
        }
    };
    return BitMatrixParser;
}());

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the
decoding caller. Callers are expected to process this.

\@see com.google.zxing.common.DecoderResult#getOther()
 */
var QRCodeDecoderMetaData = (function () {
    /**
     * @param {?} mirrored
     */
    function QRCodeDecoderMetaData(mirrored) {
        this.mirrored = mirrored;
    }
    /**
     * @return {?} true if the QR Code was mirrored.
     */
    QRCodeDecoderMetaData.prototype.isMirrored = function () {
        return this.mirrored;
    };
    /**
     * Apply the result points' order correction due to mirroring.
    
    \@param points Array of points to apply mirror correction to.
     * @param {?} points
     * @return {?}
     */
    QRCodeDecoderMetaData.prototype.applyMirroredCorrection = function (points) {
        if (!this.mirrored || points === null || points.length < 3) {
            return;
        }
        var /** @type {?} */ bottomLeft = points[0];
        points[0] = points[2];
        points[2] = bottomLeft;
        // No need to 'fix' top-left and alignment pattern.
    };
    return QRCodeDecoderMetaData;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into
multiple blocks, each of which is a unit of data and error-correction codewords. Each
is represented by an instance of this class.</p>

\@author Sean Owen
 */
var DataBlock = (function () {
    /**
     * @param {?} numDataCodewords
     * @param {?} codewords
     */
    function DataBlock(numDataCodewords /*int*/, codewords) {
        this.numDataCodewords = numDataCodewords; /*int*/
        this.codewords = codewords;
    }
    /**
     * <p>When QR Codes use multiple data blocks, they are actually interleaved.
    That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
    method will separate the data into original blocks.</p>
    
    \@param rawCodewords bytes as read directly from the QR Code
    \@param version version of the QR Code
    \@param ecLevel error-correction level of the QR Code
    \@return DataBlocks containing original bytes, "de-interleaved" from representation in the
            QR Code
     * @param {?} rawCodewords
     * @param {?} version
     * @param {?} ecLevel
     * @return {?}
     */
    DataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {
        if (rawCodewords.length != version.getTotalCodewords()) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        // Figure out the number and size of data blocks used by this version and
        // error correction level
        var /** @type {?} */ ecBlocks = version.getECBlocksForLevel(ecLevel);
        // First count the total number of data blocks
        var /** @type {?} */ totalBlocks = 0;
        var /** @type {?} */ ecBlockArray = ecBlocks.getECBlocks();
        for (var _i = 0, ecBlockArray_1 = ecBlockArray; _i < ecBlockArray_1.length; _i++) {
            var ecBlock = ecBlockArray_1[_i];
            totalBlocks += ecBlock.getCount();
        }
        // Now establish DataBlocks of the appropriate size and number of data codewords
        var /** @type {?} */ result = new Array(totalBlocks);
        var /** @type {?} */ numResultBlocks = 0;
        for (var _a = 0, ecBlockArray_2 = ecBlockArray; _a < ecBlockArray_2.length; _a++) {
            var ecBlock = ecBlockArray_2[_a];
            for (var /** @type {?} */ i = 0; i < ecBlock.getCount(); i++) {
                var /** @type {?} */ numDataCodewords = ecBlock.getDataCodewords();
                var /** @type {?} */ numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
                result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
            }
        }
        // All blocks have the same amount of data, except that the last n
        // (where n may be 0) have 1 more byte. Figure out where these start.
        var /** @type {?} */ shorterBlocksTotalCodewords = result[0].codewords.length;
        var /** @type {?} */ longerBlocksStartAt = result.length - 1;
        // TYPESCRIPTPORT: check length is correct here
        while (longerBlocksStartAt >= 0) {
            var /** @type {?} */ numCodewords = result[longerBlocksStartAt].codewords.length;
            if (numCodewords === shorterBlocksTotalCodewords) {
                break;
            }
            longerBlocksStartAt--;
        }
        longerBlocksStartAt++;
        var /** @type {?} */ shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
        // The last elements of result may be 1 element longer
        // first fill out as many elements as all of them have
        var /** @type {?} */ rawCodewordsOffset = 0;
        for (var /** @type {?} */ i = 0; i < shorterBlocksNumDataCodewords; i++) {
            for (var /** @type {?} */ j = 0; j < numResultBlocks; j++) {
                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
            }
        }
        // Fill out the last data block in the longer ones
        for (var /** @type {?} */ j = longerBlocksStartAt; j < numResultBlocks; j++) {
            result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
        }
        // Now add in error correction blocks
        var /** @type {?} */ max = result[0].codewords.length;
        for (var /** @type {?} */ i = shorterBlocksNumDataCodewords; i < max; i++) {
            for (var /** @type {?} */ j = 0; j < numResultBlocks; j++) {
                var /** @type {?} */ iOffset = j < longerBlocksStartAt ? i : i + 1;
                result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
            }
        }
        return result;
    };
    /**
     * @return {?}
     */
    DataBlock.prototype.getNumDataCodewords = function () {
        return this.numDataCodewords;
    };
    /**
     * @return {?}
     */
    DataBlock.prototype.getCodewords = function () {
        return this.codewords;
    };
    return DataBlock;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.common {*/
/**
 * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the
number of bits read is not often a multiple of 8.</p>

<p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array
it passed in, in which case all bets are off.</p>

\@author Sean Owen
 */
var BitSource = (function () {
    /**
     * @param {?} bytes bytes from which this will read bits. Bits will be read from the first byte first.
     */
    function BitSource(bytes) {
        this.bytes = bytes;
        this.byteOffset = 0;
        this.bitOffset = 0;
    }
    /**
     * @return {?} index of next bit in current byte which would be read by the next call to {\@link #readBits(int)}.
     */
    BitSource.prototype.getBitOffset = function () {
        return this.bitOffset;
    };
    /**
     * @return {?} index of next byte in input byte array which would be read by the next call to {\@link #readBits(int)}.
     */
    BitSource.prototype.getByteOffset = function () {
        return this.byteOffset;
    };
    /**
     * @param {?} numBits number of bits to read
     * @return {?}
     */
    BitSource.prototype.readBits = function (numBits /*int*/) {
        if (numBits < 1 || numBits > 32 || numBits > this.available()) {
            throw new Exception(Exception.IllegalArgumentException, "" + numBits);
        }
        var /** @type {?} */ result = 0;
        var /** @type {?} */ bitOffset = this.bitOffset;
        var /** @type {?} */ byteOffset = this.byteOffset;
        var /** @type {?} */ bytes = this.bytes;
        // First, read remainder from current byte
        if (bitOffset > 0) {
            var /** @type {?} */ bitsLeft = 8 - bitOffset;
            var /** @type {?} */ toRead = numBits < bitsLeft ? numBits : bitsLeft;
            var /** @type {?} */ bitsToNotRead = bitsLeft - toRead;
            var /** @type {?} */ mask = (0xFF >> (8 - toRead)) << bitsToNotRead;
            result = (bytes[byteOffset] & mask) >> bitsToNotRead;
            numBits -= toRead;
            bitOffset += toRead;
            if (bitOffset == 8) {
                bitOffset = 0;
                byteOffset++;
            }
        }
        // Next read whole bytes
        if (numBits > 0) {
            while (numBits >= 8) {
                result = (result << 8) | (bytes[byteOffset] & 0xFF);
                byteOffset++;
                numBits -= 8;
            }
            // Finally read a partial byte
            if (numBits > 0) {
                var /** @type {?} */ bitsToNotRead = 8 - numBits;
                var /** @type {?} */ mask = (0xFF >> bitsToNotRead) << bitsToNotRead;
                result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);
                bitOffset += numBits;
            }
        }
        this.bitOffset = bitOffset;
        this.byteOffset = byteOffset;
        return result;
    };
    /**
     * @return {?} number of bits that can be read successfully
     */
    BitSource.prototype.available = function () {
        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
    };
    return BitSource;
}());

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.common {*/
/**
 * Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1
of ISO 18004.

\@author Sean Owen
 */
var CharacterSetECI = (function () {
    /**
     * @param {?} valueIdentifier
     * @param {?} valuesParam
     * @param {?} name
     * @param {...?} otherEncodingNames
     */
    function CharacterSetECI(valueIdentifier, valuesParam, name) {
        var otherEncodingNames = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            otherEncodingNames[_i - 3] = arguments[_i];
        }
        this.valueIdentifier = valueIdentifier;
        this.name = name;
        if (typeof valuesParam === "number") {
            this.values = Int32Array.from([valuesParam]);
        }
        else {
            this.values = valuesParam;
        }
        this.otherEncodingNames = otherEncodingNames;
        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
        CharacterSetECI.NAME_TO_ECI.set(name, this);
        var values = this.values;
        for (var i = 0, length_1 = values.length; i !== length_1; i++) {
            var v = values[i];
            CharacterSetECI.VALUES_TO_ECI.set(v, this);
        }
        for (var _a = 0, otherEncodingNames_1 = otherEncodingNames; _a < otherEncodingNames_1.length; _a++) {
            var otherName = otherEncodingNames_1[_a];
            CharacterSetECI.NAME_TO_ECI.set(otherName, this);
        }
    }
    /**
     * @return {?}
     */
    CharacterSetECI.prototype.getValueIdentifier = function () {
        return this.valueIdentifier;
    };
    /**
     * @return {?}
     */
    CharacterSetECI.prototype.getName = function () {
        return this.name;
    };
    /**
     * @return {?}
     */
    CharacterSetECI.prototype.getValue = function () {
        return this.values[0];
    };
    /**
     * @param {?} value character set ECI value
     * @return {?}
     */
    CharacterSetECI.getCharacterSetECIByValue = function (value /*int*/) {
        if (value < 0 || value >= 900) {
            throw new Exception(Exception.FormatException, "incorect value");
        }
        var /** @type {?} */ characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);
        if (undefined === characterSet) {
            throw new Exception(Exception.FormatException, "incorect value");
        }
        return characterSet;
    };
    /**
     * @param {?} name character set ECI encoding name
     * @return {?}
     */
    CharacterSetECI.getCharacterSetECIByName = function (name) {
        var /** @type {?} */ characterSet = CharacterSetECI.NAME_TO_ECI.get(name);
        if (undefined === characterSet) {
            throw new Exception(Exception.FormatException, "incorect value");
        }
        return characterSet;
    };
    /**
     * @param {?} o
     * @return {?}
     */
    CharacterSetECI.prototype.equals = function (o) {
        if (!(o instanceof CharacterSetECI)) {
            return false;
        }
        var /** @type {?} */ other = (o);
        return this.getName() === other.getName();
    };
    return CharacterSetECI;
}());
CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();
CharacterSetECI.VALUES_TO_ECI = new Map();
CharacterSetECI.NAME_TO_ECI = new Map();
CharacterSetECI.Cp437 = new CharacterSetECI(0 /* Cp437 */, Int32Array.from([0, 2]), "Cp437");
CharacterSetECI.ISO8859_1 = new CharacterSetECI(1 /* ISO8859_1 */, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1");
CharacterSetECI.ISO8859_2 = new CharacterSetECI(2 /* ISO8859_2 */, 4, "ISO-8859-2", "ISO88592", "ISO8859_2");
CharacterSetECI.ISO8859_3 = new CharacterSetECI(3 /* ISO8859_3 */, 5, "ISO-8859-3", "ISO88593", "ISO8859_3");
CharacterSetECI.ISO8859_4 = new CharacterSetECI(4 /* ISO8859_4 */, 6, "ISO-8859-4", "ISO88594", "ISO8859_4");
CharacterSetECI.ISO8859_5 = new CharacterSetECI(5 /* ISO8859_5 */, 7, "ISO-8859-5", "ISO88595", "ISO8859_5");
CharacterSetECI.ISO8859_6 = new CharacterSetECI(6 /* ISO8859_6 */, 8, "ISO-8859-6", "ISO88596", "ISO8859_6");
CharacterSetECI.ISO8859_7 = new CharacterSetECI(7 /* ISO8859_7 */, 9, "ISO-8859-7", "ISO88597", "ISO8859_7");
CharacterSetECI.ISO8859_8 = new CharacterSetECI(8 /* ISO8859_8 */, 10, "ISO-8859-8", "ISO88598", "ISO8859_8");
CharacterSetECI.ISO8859_9 = new CharacterSetECI(9 /* ISO8859_9 */, 11, "ISO-8859-9", "ISO88599", "ISO8859_9");
CharacterSetECI.ISO8859_10 = new CharacterSetECI(10 /* ISO8859_10 */, 12, "ISO-8859-10", "ISO885910", "ISO8859_10");
CharacterSetECI.ISO8859_11 = new CharacterSetECI(11 /* ISO8859_11 */, 13, "ISO-8859-11", "ISO885911", "ISO8859_11");
CharacterSetECI.ISO8859_13 = new CharacterSetECI(12 /* ISO8859_13 */, 15, "ISO-8859-13", "ISO885913", "ISO8859_13");
CharacterSetECI.ISO8859_14 = new CharacterSetECI(13 /* ISO8859_14 */, 16, "ISO-8859-14", "ISO885914", "ISO8859_14");
CharacterSetECI.ISO8859_15 = new CharacterSetECI(14 /* ISO8859_15 */, 17, "ISO-8859-15", "ISO885915", "ISO8859_15");
CharacterSetECI.ISO8859_16 = new CharacterSetECI(15 /* ISO8859_16 */, 18, "ISO-8859-16", "ISO885916", "ISO8859_16");
CharacterSetECI.SJIS = new CharacterSetECI(16 /* SJIS */, 20, "SJIS", "Shift_JIS");
CharacterSetECI.Cp1250 = new CharacterSetECI(17 /* Cp1250 */, 21, "Cp1250", "windows-1250");
CharacterSetECI.Cp1251 = new CharacterSetECI(18 /* Cp1251 */, 22, "Cp1251", "windows-1251");
CharacterSetECI.Cp1252 = new CharacterSetECI(19 /* Cp1252 */, 23, "Cp1252", "windows-1252");
CharacterSetECI.Cp1256 = new CharacterSetECI(20 /* Cp1256 */, 24, "Cp1256", "windows-1256");
CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(21 /* UnicodeBigUnmarked */, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig");
CharacterSetECI.UTF8 = new CharacterSetECI(22 /* UTF8 */, 26, "UTF8", "UTF-8");
CharacterSetECI.ASCII = new CharacterSetECI(23 /* ASCII */, Int32Array.from([27, 170]), "ASCII", "US-ASCII");
CharacterSetECI.Big5 = new CharacterSetECI(24 /* Big5 */, 28, "Big5");
CharacterSetECI.GB18030 = new CharacterSetECI(25 /* GB18030 */, 29, "GB18030", "GB2312", "EUC_CN", "GBK");
CharacterSetECI.EUC_KR = new CharacterSetECI(26 /* EUC_KR */, 30, "EUC_KR", "EUC-KR");

/**
 * <p>Encapsulates the result of decoding a matrix of bits. This typically
applies to 2D barcode formats. For now it contains the raw bytes obtained,
as well as a String interpretation of those bytes, if applicable.</p>

\@author Sean Owen
 */
var DecoderResult = (function () {
    /**
     * @param {?} rawBytes
     * @param {?} text
     * @param {?} byteSegments
     * @param {?} ecLevel
     * @param {?} structuredAppendSequenceNumber
     * @param {?} structuredAppendParity
     */
    function DecoderResult(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber /*int*/, structuredAppendParity /*int*/) {
        this.rawBytes = rawBytes;
        this.text = text;
        this.byteSegments = byteSegments;
        this.ecLevel = ecLevel;
        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber; /*int*/
        this.structuredAppendParity = structuredAppendParity; /*int*/
        this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;
    }
    /**
     * @return {?} raw bytes representing the result, or {\@code null} if not applicable
     */
    DecoderResult.prototype.getRawBytes = function () {
        return this.rawBytes;
    };
    /**
     * @return {?} how many bits of {\@link #getRawBytes()} are valid; typically 8 times its length
     */
    DecoderResult.prototype.getNumBits = function () {
        return this.numBits;
    };
    /**
     * @param {?} numBits overrides the number of bits that are valid in {\@link #getRawBytes()}
     * @return {?}
     */
    DecoderResult.prototype.setNumBits = function (numBits /*int*/) {
        this.numBits = numBits;
    };
    /**
     * @return {?} text representation of the result
     */
    DecoderResult.prototype.getText = function () {
        return this.text;
    };
    /**
     * @return {?} list of byte segments in the result, or {\@code null} if not applicable
     */
    DecoderResult.prototype.getByteSegments = function () {
        return this.byteSegments;
    };
    /**
     * @return {?} name of error correction level used, or {\@code null} if not applicable
     */
    DecoderResult.prototype.getECLevel = function () {
        return this.ecLevel;
    };
    /**
     * @return {?} number of errors corrected, or {\@code null} if not applicable
     */
    DecoderResult.prototype.getErrorsCorrected = function () {
        return this.errorsCorrected;
    };
    /**
     * @param {?} errorsCorrected
     * @return {?}
     */
    DecoderResult.prototype.setErrorsCorrected = function (errorsCorrected /*Integer*/) {
        this.errorsCorrected = errorsCorrected;
    };
    /**
     * @return {?} number of erasures corrected, or {\@code null} if not applicable
     */
    DecoderResult.prototype.getErasures = function () {
        return this.erasures;
    };
    /**
     * @param {?} erasures
     * @return {?}
     */
    DecoderResult.prototype.setErasures = function (erasures /*Integer*/) {
        this.erasures = erasures;
    };
    /**
     * @return {?} arbitrary additional metadata
     */
    DecoderResult.prototype.getOther = function () {
        return this.other;
    };
    /**
     * @param {?} other
     * @return {?}
     */
    DecoderResult.prototype.setOther = function (other) {
        this.other = other;
    };
    /**
     * @return {?}
     */
    DecoderResult.prototype.hasStructuredAppend = function () {
        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
    };
    /**
     * @return {?}
     */
    DecoderResult.prototype.getStructuredAppendParity = function () {
        return this.structuredAppendParity;
    };
    /**
     * @return {?}
     */
    DecoderResult.prototype.getStructuredAppendSequenceNumber = function () {
        return this.structuredAppendSequenceNumber;
    };
    return DecoderResult;
}());

/*
 * Copyright (C) 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Common string-related functions.

\@author Sean Owen
\@author Alex Dupre
 */
var StringUtils = (function () {
    function StringUtils() {
    }
    /**
     * @return {?}
     */
    StringUtils.prototype.StringUtils = function () { };
    /**
     * @param {?} bytes bytes encoding a string, whose encoding should be guessed
     * @param {?} hints
     * @return {?}
     */
    StringUtils.guessEncoding = function (bytes, hints) {
        if (hints !== null && hints !== undefined && undefined !== hints.get(4 /* CHARACTER_SET */)) {
            return hints.get(4 /* CHARACTER_SET */).toString();
        }
        // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,
        // which should be by far the most common encodings.
        var /** @type {?} */ length = bytes.length;
        var /** @type {?} */ canBeISO88591 = true;
        var /** @type {?} */ canBeShiftJIS = true;
        var /** @type {?} */ canBeUTF8 = true;
        var /** @type {?} */ utf8BytesLeft = 0;
        //int utf8LowChars = 0
        var /** @type {?} */ utf2BytesChars = 0;
        var /** @type {?} */ utf3BytesChars = 0;
        var /** @type {?} */ utf4BytesChars = 0;
        var /** @type {?} */ sjisBytesLeft = 0;
        //int sjisLowChars = 0
        var /** @type {?} */ sjisKatakanaChars = 0;
        //int sjisDoubleBytesChars = 0
        var /** @type {?} */ sjisCurKatakanaWordLength = 0;
        var /** @type {?} */ sjisCurDoubleBytesWordLength = 0;
        var /** @type {?} */ sjisMaxKatakanaWordLength = 0;
        var /** @type {?} */ sjisMaxDoubleBytesWordLength = 0;
        //int isoLowChars = 0
        //int isoHighChars = 0
        var /** @type {?} */ isoHighOther = 0;
        var /** @type {?} */ utf8bom = bytes.length > 3 &&
            bytes[0] == 0xEF &&
            bytes[1] == 0xBB &&
            bytes[2] == 0xBF;
        for (var /** @type {?} */ i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {
            var /** @type {?} */ value = bytes[i] & 0xFF;
            // UTF-8 stuff
            if (canBeUTF8) {
                if (utf8BytesLeft > 0) {
                    if ((value & 0x80) == 0) {
                        canBeUTF8 = false;
                    }
                    else {
                        utf8BytesLeft--;
                    }
                }
                else if ((value & 0x80) != 0) {
                    if ((value & 0x40) == 0) {
                        canBeUTF8 = false;
                    }
                    else {
                        utf8BytesLeft++;
                        if ((value & 0x20) == 0) {
                            utf2BytesChars++;
                        }
                        else {
                            utf8BytesLeft++;
                            if ((value & 0x10) == 0) {
                                utf3BytesChars++;
                            }
                            else {
                                utf8BytesLeft++;
                                if ((value & 0x08) == 0) {
                                    utf4BytesChars++;
                                }
                                else {
                                    canBeUTF8 = false;
                                }
                            }
                        }
                    }
                } //else {
                //utf8LowChars++
                //}
            }
            // ISO-8859-1 stuff
            if (canBeISO88591) {
                if (value > 0x7F && value < 0xA0) {
                    canBeISO88591 = false;
                }
                else if (value > 0x9F) {
                    if (value < 0xC0 || value == 0xD7 || value == 0xF7) {
                        isoHighOther++;
                    } //else {
                    //isoHighChars++
                    //}
                } //else {
                //isoLowChars++
                //}
            }
            // Shift_JIS stuff
            if (canBeShiftJIS) {
                if (sjisBytesLeft > 0) {
                    if (value < 0x40 || value == 0x7F || value > 0xFC) {
                        canBeShiftJIS = false;
                    }
                    else {
                        sjisBytesLeft--;
                    }
                }
                else if (value == 0x80 || value == 0xA0 || value > 0xEF) {
                    canBeShiftJIS = false;
                }
                else if (value > 0xA0 && value < 0xE0) {
                    sjisKatakanaChars++;
                    sjisCurDoubleBytesWordLength = 0;
                    sjisCurKatakanaWordLength++;
                    if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                        sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
                    }
                }
                else if (value > 0x7F) {
                    sjisBytesLeft++;
                    //sjisDoubleBytesChars++
                    sjisCurKatakanaWordLength = 0;
                    sjisCurDoubleBytesWordLength++;
                    if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                        sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
                    }
                }
                else {
                    //sjisLowChars++
                    sjisCurKatakanaWordLength = 0;
                    sjisCurDoubleBytesWordLength = 0;
                }
            }
        }
        if (canBeUTF8 && utf8BytesLeft > 0) {
            canBeUTF8 = false;
        }
        if (canBeShiftJIS && sjisBytesLeft > 0) {
            canBeShiftJIS = false;
        }
        // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done
        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
            return StringUtils.UTF8;
        }
        // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done
        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
            return StringUtils.SHIFT_JIS;
        }
        // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:
        // - If we saw
        //   - only two consecutive katakana chars in the whole text, or
        //   - at least 10% of bytes that could be "upper" not-alphanumeric Latin1,
        // - then we conclude Shift_JIS, else ISO-8859-1
        if (canBeISO88591 && canBeShiftJIS) {
            return (sjisMaxKatakanaWordLength == 2 && sjisKatakanaChars == 2) || isoHighOther * 10 >= length
                ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
        }
        // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding
        if (canBeISO88591) {
            return StringUtils.ISO88591;
        }
        if (canBeShiftJIS) {
            return StringUtils.SHIFT_JIS;
        }
        if (canBeUTF8) {
            return StringUtils.UTF8;
        }
        // Otherwise, we take a wild guess with platform encoding
        return StringUtils.PLATFORM_DEFAULT_ENCODING;
    };
    return StringUtils;
}());
StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName();
StringUtils.GB2312 = "GB2312";
StringUtils.EUC_JP = "EUC_JP";
StringUtils.UTF8 = CharacterSetECI.UTF8.getName();
StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8;
StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName();
StringUtils.ASSUME_SHIFT_JIS = false;

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing.qrcode.decoder {*/
/**
 * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which
data can be encoded to bits in the QR code standard.</p>

\@author Sean Owen
 */
var Mode = (function () {
    /**
     * @param {?} value
     * @param {?} stringValue
     * @param {?} characterCountBitsForVersions
     * @param {?} bits
     */
    function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {
        this.value = value;
        this.stringValue = stringValue;
        this.characterCountBitsForVersions = characterCountBitsForVersions;
        this.bits = bits; /*int*/
        Mode.FOR_BITS.set(bits, this);
        Mode.FOR_VALUE.set(value, this);
    }
    /**
     * @param {?} bits four bits encoding a QR Code data mode
     * @return {?}
     */
    Mode.forBits = function (bits /*int*/) {
        var /** @type {?} */ mode = Mode.FOR_BITS.get(bits);
        if (undefined === mode) {
            throw new Exception(Exception.IllegalArgumentException);
        }
        return mode;
    };
    /**
     * @param {?} version version in question
     * @return {?}
     */
    Mode.prototype.getCharacterCountBits = function (version) {
        var /** @type {?} */ number = version.getVersionNumber();
        var /** @type {?} */ offset;
        if (number <= 9) {
            offset = 0;
        }
        else if (number <= 26) {
            offset = 1;
        }
        else {
            offset = 2;
        }
        return this.characterCountBitsForVersions[offset];
    };
    /**
     * @return {?}
     */
    Mode.prototype.getValue = function () {
        return this.value;
    };
    /**
     * @return {?}
     */
    Mode.prototype.getBits = function () {
        return this.bits;
    };
    /**
     * @param {?} o
     * @return {?}
     */
    Mode.prototype.equals = function (o) {
        if (!(o instanceof Mode)) {
            return false;
        }
        var /** @type {?} */ other = (o);
        return this.value === other.value;
    };
    /**
     * @return {?}
     */
    Mode.prototype.toString = function () {
        return this.stringValue;
    };
    return Mode;
}());
Mode.FOR_BITS = new Map();
Mode.FOR_VALUE = new Map();
Mode.TERMINATOR = new Mode(0 /* TERMINATOR */, "TERMINATOR", Int32Array.from([0, 0, 0]), 0x00);
Mode.NUMERIC = new Mode(1 /* NUMERIC */, "NUMERIC", Int32Array.from([10, 12, 14]), 0x01);
Mode.ALPHANUMERIC = new Mode(2 /* ALPHANUMERIC */, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 0x02);
Mode.STRUCTURED_APPEND = new Mode(3 /* STRUCTURED_APPEND */, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 0x03);
Mode.BYTE = new Mode(4 /* BYTE */, "BYTE", Int32Array.from([8, 16, 16]), 0x04);
Mode.ECI = new Mode(5 /* ECI */, "ECI", Int32Array.from([0, 0, 0]), 0x07);
Mode.KANJI = new Mode(6 /* KANJI */, "KANJI", Int32Array.from([8, 10, 12]), 0x08);
Mode.FNC1_FIRST_POSITION = new Mode(7 /* FNC1_FIRST_POSITION */, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 0x05);
Mode.FNC1_SECOND_POSITION = new Mode(8 /* FNC1_SECOND_POSITION */, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 0x09);
/**
 * See GBT 18284-2000; "Hanzi" is a transliteration of this mode name.
 */
Mode.HANZI = new Mode(9 /* HANZI */, "HANZI", Int32Array.from([8, 10, 12]), 0x0D);

var StringEncoding = (function () {
    function StringEncoding() {
    }
    /**
     * @param {?} bytes
     * @param {?} encoding
     * @return {?}
     */
    StringEncoding.decode = function (bytes, encoding) {
        if (StringEncoding.isBrowser()) {
            var /** @type {?} */ TextDecoderBrowser = window['TextDecoder'];
            // use TextEncoder if is available (should be in newer browsers) 
            if (undefined !== TextDecoderBrowser) {
                console.log(TextDecoderBrowser);
                return new TextDecoderBrowser(encoding).decode(bytes);
            }
            else {
                // fall back to minimal decoding
                return StringEncoding.decodeFallBack(bytes, encoding);
            }
        }
        else {
            var /** @type {?} */ TextDecoderFromTEClass = require('text-encoding').TextDecoder;
            return new TextDecoderFromTEClass(encoding).decode(bytes);
        }
    };
    /**
     * @param {?} s
     * @param {?} encoding
     * @return {?}
     */
    StringEncoding.encode = function (s, encoding) {
        if (StringEncoding.isBrowser()) {
            var /** @type {?} */ TextEncoderBrowser = window['TextEncoder'];
            // use TextEncoder if is available (should be in newer browsers) 
            var /** @type {?} */ ec = CharacterSetECI.getCharacterSetECIByName(encoding);
            if (undefined !== TextEncoderBrowser) {
                // TODO: TextEncoder only supports utf-8 encoding as per specs
                return new TextEncoderBrowser(encoding).encode(s);
            }
            else {
                // fall back to minimal decoding
                return StringEncoding.encodeFallBack(s, encoding);
            }
        }
        else {
            // Note: NONSTANDARD_allowLegacyEncoding is required for other encodings than UTF8
            // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org
            var /** @type {?} */ TextEncoderFromTEClass = require('text-encoding').TextEncoder;
            return new TextEncoderFromTEClass(encoding, { NONSTANDARD_allowLegacyEncoding: true }).encode(s);
        }
    };
    /**
     * @return {?}
     */
    StringEncoding.isBrowser = function () {
        return typeof window !== 'undefined' && ({}).toString.call(window) === '[object Window]';
    };
    /**
     * @param {?} bytes
     * @param {?} encoding
     * @return {?}
     */
    StringEncoding.decodeFallBack = function (bytes, encoding) {
        var /** @type {?} */ ec = CharacterSetECI.getCharacterSetECIByName(encoding);
        if (ec.equals(CharacterSetECI.UTF8) || ec.equals(CharacterSetECI.ISO8859_1) || ec.equals(CharacterSetECI.ASCII)) {
            var /** @type {?} */ s = '';
            for (var /** @type {?} */ i = 0; i < bytes.length; i++) {
                var /** @type {?} */ h = bytes[i].toString(16);
                if (h.length < 2) {
                    h = '0' + h;
                }
                
            }
            return decodeURIComponent(s);
        }
        else if (ec.equals(CharacterSetECI.UnicodeBigUnmarked)) {
            return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
        }
        else {
            throw new Exception(Exception.UnsupportedOperationException, "encoding " + encoding + " not supported");
        }
    };
    /**
     * @param {?} s
     * @param {?} encoding
     * @return {?}
     */
    StringEncoding.encodeFallBack = function (s, encoding) {
        // TODO: encode
        return null;
    };
    return StringEncoding;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes
in one QR Code. This class decodes the bits back into text.</p>

<p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>

\@author Sean Owen
 */
var DecodedBitStreamParser = (function () {
    function DecodedBitStreamParser() {
    }
    /**
     * @param {?} bytes
     * @param {?} version
     * @param {?} ecLevel
     * @param {?} hints
     * @return {?}
     */
    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {
        var /** @type {?} */ bits = new BitSource(bytes);
        var /** @type {?} */ result = new StringBuilder();
        var /** @type {?} */ byteSegments = new Array(); //1
        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below
        var /** @type {?} */ symbolSequence = -1;
        var /** @type {?} */ parityData = -1;
        try {
            var /** @type {?} */ currentCharacterSetECI = null;
            var /** @type {?} */ fc1InEffect = false;
            var /** @type {?} */ mode = void 0;
            do {
                // While still another segment to read...
                if (bits.available() < 4) {
                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here
                    mode = Mode.TERMINATOR;
                }
                else {
                    var /** @type {?} */ modeBits = bits.readBits(4);
                    mode = Mode.forBits(modeBits); // mode is encoded by 4 bits
                }
                switch (mode) {
                    case Mode.TERMINATOR:
                        break;
                    case Mode.FNC1_FIRST_POSITION:
                    case Mode.FNC1_SECOND_POSITION:
                        // We do little with FNC1 except alter the parsed result a bit according to the spec
                        fc1InEffect = true;
                        break;
                    case Mode.STRUCTURED_APPEND:
                        if (bits.available() < 16) {
                            throw new Exception(Exception.FormatException);
                        }
                        // sequence number and parity is added later to the result metadata
                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue
                        symbolSequence = bits.readBits(8);
                        parityData = bits.readBits(8);
                        break;
                    case Mode.ECI:
                        // Count doesn't apply to ECI
                        var /** @type {?} */ value = DecodedBitStreamParser.parseECIValue(bits);
                        currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);
                        if (currentCharacterSetECI === null) {
                            throw new Exception(Exception.FormatException);
                        }
                        break;
                    case Mode.HANZI:
                        // First handle Hanzi mode which does not start with character count
                        // Chinese mode contains a sub set indicator right after mode indicator
                        var /** @type {?} */ subset = bits.readBits(4);
                        var /** @type {?} */ countHanzi = bits.readBits(mode.getCharacterCountBits(version));
                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {
                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);
                        }
                        break;
                    default:
                        // "Normal" QR code modes:
                        // How many characters will follow, encoded in this mode?
                        var /** @type {?} */ count = bits.readBits(mode.getCharacterCountBits(version));
                        switch (mode) {
                            case Mode.NUMERIC:
                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);
                                break;
                            case Mode.ALPHANUMERIC:
                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
                                break;
                            case Mode.BYTE:
                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
                                break;
                            case Mode.KANJI:
                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);
                                break;
                            default:
                                throw new Exception(Exception.FormatException);
                        }
                        break;
                }
            } while (mode !== Mode.TERMINATOR);
        }
        catch (iae /*: IllegalArgumentException*/) {
            // from readBits() calls
            throw new Exception(Exception.FormatException);
        }
        return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
    };
    /**
     * See specification GBT 18284-2000
     * @param {?} bits
     * @param {?} result
     * @param {?} count
     * @return {?}
     */
    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {
        // Don't crash trying to read more bits than we have available.
        if (count * 13 > bits.available()) {
            throw new Exception(Exception.FormatException);
        }
        // Each character will require 2 bytes. Read the characters as 2-byte pairs
        // and decode as GB2312 afterwards
        var /** @type {?} */ buffer = new Uint8Array(2 * count);
        var /** @type {?} */ offset = 0;
        while (count > 0) {
            // Each 13 bits encodes a 2-byte character
            var /** @type {?} */ twoBytes = bits.readBits(13);
            var /** @type {?} */ assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);
            if (assembledTwoBytes < 0x003BF) {
                // In the 0xA1A1 to 0xAAFE range
                assembledTwoBytes += 0x0A1A1;
            }
            else {
                // In the 0xB0A1 to 0xFAFE range
                assembledTwoBytes += 0x0A6A1;
            }
            buffer[offset] = ((assembledTwoBytes >> 8) & 0xFF);
            buffer[offset + 1] = (assembledTwoBytes & 0xFF);
            offset += 2;
            count--;
        }
        try {
            result.append(StringEncoding.decode(buffer, StringUtils.GB2312));
            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point
        }
        catch (ignored /*: UnsupportedEncodingException*/) {
            throw new Exception(Exception.FormatException, ignored);
        }
    };
    /**
     * @param {?} bits
     * @param {?} result
     * @param {?} count
     * @return {?}
     */
    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {
        // Don't crash trying to read more bits than we have available.
        if (count * 13 > bits.available()) {
            throw new Exception(Exception.FormatException);
        }
        // Each character will require 2 bytes. Read the characters as 2-byte pairs
        // and decode as Shift_JIS afterwards
        var /** @type {?} */ buffer = new Uint8Array(2 * count);
        var /** @type {?} */ offset = 0;
        while (count > 0) {
            // Each 13 bits encodes a 2-byte character
            var /** @type {?} */ twoBytes = bits.readBits(13);
            var /** @type {?} */ assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);
            if (assembledTwoBytes < 0x01F00) {
                // In the 0x8140 to 0x9FFC range
                assembledTwoBytes += 0x08140;
            }
            else {
                // In the 0xE040 to 0xEBBF range
                assembledTwoBytes += 0x0C140;
            }
            buffer[offset] = (assembledTwoBytes >> 8);
            buffer[offset + 1] = assembledTwoBytes;
            offset += 2;
            count--;
        }
        // Shift_JIS may not be supported in some environments:
        try {
            result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));
            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point
        }
        catch (ignored /*: UnsupportedEncodingException*/) {
            throw new Exception(Exception.FormatException, ignored);
        }
    };
    /**
     * @param {?} bits
     * @param {?} result
     * @param {?} count
     * @param {?} currentCharacterSetECI
     * @param {?} byteSegments
     * @param {?} hints
     * @return {?}
     */
    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {
        // Don't crash trying to read more bits than we have available.
        if (8 * count > bits.available()) {
            throw new Exception(Exception.FormatException);
        }
        var /** @type {?} */ readBytes = new Uint8Array(count);
        for (var /** @type {?} */ i = 0; i < count; i++) {
            readBytes[i] = bits.readBits(8);
        }
        var /** @type {?} */ encoding;
        if (currentCharacterSetECI === null) {
            // The spec isn't clear on this mode; see
            // section 6.4.5: t does not say which encoding to assuming
            // upon decoding. I have seen ISO-8859-1 used as well as
            // Shift_JIS -- without anything like an ECI designator to
            // give a hint.
            encoding = StringUtils.guessEncoding(readBytes, hints);
        }
        else {
            encoding = currentCharacterSetECI.getName();
        }
        try {
            result.append(StringEncoding.decode(readBytes, encoding));
        }
        catch (ignored /*: UnsupportedEncodingException*/) {
            throw new Exception(Exception.FormatException, ignored);
        }
        byteSegments.push(readBytes);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {
        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {
            throw new Exception(Exception.FormatException);
        }
        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];
    };
    /**
     * @param {?} bits
     * @param {?} result
     * @param {?} count
     * @param {?} fc1InEffect
     * @return {?}
     */
    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {
        // Read two characters at a time
        var /** @type {?} */ start = result.length();
        while (count > 1) {
            if (bits.available() < 11) {
                throw new Exception(Exception.FormatException);
            }
            var /** @type {?} */ nextTwoCharsBits = bits.readBits(11);
            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));
            count -= 2;
        }
        if (count == 1) {
            // special case: one character left
            if (bits.available() < 6) {
                throw new Exception(Exception.FormatException);
            }
            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));
        }
        // See section 6.4.8.1, 6.4.8.2
        if (fc1InEffect) {
            // We need to massage the result a bit if in an FNC1 mode:
            for (var /** @type {?} */ i = start; i < result.length(); i++) {
                if (result.charAt(i) === '%') {
                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {
                        // %% is rendered as %
                        result.deleteCharAt(i + 1);
                    }
                    else {
                        // In alpha mode, % should be converted to FNC1 separator 0x1D
                        result.setCharAt(i, String.fromCharCode(0x1D));
                    }
                }
            }
        }
    };
    /**
     * @param {?} bits
     * @param {?} result
     * @param {?} count
     * @return {?}
     */
    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {
        // Read three digits at a time
        while (count >= 3) {
            // Each 10 bits encodes three digits
            if (bits.available() < 10) {
                throw new Exception(Exception.FormatException);
            }
            var /** @type {?} */ threeDigitsBits = bits.readBits(10);
            if (threeDigitsBits >= 1000) {
                throw new Exception(Exception.FormatException);
            }
            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));
            count -= 3;
        }
        if (count == 2) {
            // Two digits left over to read, encoded in 7 bits
            if (bits.available() < 7) {
                throw new Exception(Exception.FormatException);
            }
            var /** @type {?} */ twoDigitsBits = bits.readBits(7);
            if (twoDigitsBits >= 100) {
                throw new Exception(Exception.FormatException);
            }
            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));
        }
        else if (count == 1) {
            // One digit left over to read
            if (bits.available() < 4) {
                throw new Exception(Exception.FormatException);
            }
            var /** @type {?} */ digitBits = bits.readBits(4);
            if (digitBits >= 10) {
                throw new Exception(Exception.FormatException);
            }
            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));
        }
    };
    /**
     * @param {?} bits
     * @return {?}
     */
    DecodedBitStreamParser.parseECIValue = function (bits) {
        var /** @type {?} */ firstByte = bits.readBits(8);
        if ((firstByte & 0x80) === 0) {
            // just one byte
            return firstByte & 0x7F;
        }
        if ((firstByte & 0xC0) === 0x80) {
            // two bytes
            var /** @type {?} */ secondByte = bits.readBits(8);
            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;
        }
        if ((firstByte & 0xE0) === 0xC0) {
            // three bytes
            var /** @type {?} */ secondThirdBytes = bits.readBits(16);
            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;
        }
        throw new Exception(Exception.FormatException);
    };
    return DecodedBitStreamParser;
}());
/**
 * See ISO 18004:2006, 6.4.4 Table 5
 */
DecodedBitStreamParser.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
DecodedBitStreamParser.GB2312_SUBSET = 1;

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting
the QR Code from an image.</p>

\@author Sean Owen
 */
var Decoder = (function () {
    function Decoder() {
        this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);
    }
    /**
     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.
    "true" is taken to mean a black module.</p>
    
    \@param image booleans representing white/black QR Code modules
    \@param hints decoding hints that should be used to influence decoding
    \@return text and bytes encoded within the QR Code
    \@throws FormatException if the QR Code cannot be decoded
    \@throws ChecksumException if error correction fails
     * @param {?} image
     * @param {?=} hints
     * @return {?}
     */
    Decoder.prototype.decodeBooleanArray = function (image, hints) {
        return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);
    };
    /**
     * <p>Decodes a QR Code represented as a {\@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>
    
    \@param bits booleans representing white/black QR Code modules
    \@param hints decoding hints that should be used to influence decoding
    \@return text and bytes encoded within the QR Code
    \@throws FormatException if the QR Code cannot be decoded
    \@throws ChecksumException if error correction fails
     * @param {?} bits
     * @param {?=} hints
     * @return {?}
     */
    Decoder.prototype.decodeBitMatrix = function (bits, hints) {
        // Construct a parser and read version, error-correction level
        var /** @type {?} */ parser = new BitMatrixParser(bits);
        var /** @type {?} */ ex = null;
        try {
            return this.decodeBitMatrixParser(parser, hints);
        }
        catch (e /*: FormatException, ChecksumException*/) {
            ex = e;
        }
        try {
            // Revert the bit matrix
            parser.remask();
            // Will be attempting a mirrored reading of the version and format info.
            parser.setMirror(true);
            // Preemptively read the version.
            parser.readVersion();
            // Preemptively read the format information.
            parser.readFormatInformation();
            /*
             * Since we're here, this means we have successfully detected some kind
             * of version and format information when mirrored. This is a good sign,
             * that the QR code may be mirrored, and we should try once more with a
             * mirrored content.
             */
            // Prepare for a mirrored reading.
            parser.mirror();
            var /** @type {?} */ result = this.decodeBitMatrixParser(parser, hints);
            // Success! Notify the caller that the code was mirrored.
            result.setOther(new QRCodeDecoderMetaData(true));
            return result;
        }
        catch (e /*FormatException | ChecksumException*/) {
            // Throw the exception from the original reading
            if (ex !== null) {
                throw ex;
            }
            throw e;
        }
    };
    /**
     * @param {?} parser
     * @param {?} hints
     * @return {?}
     */
    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {
        var /** @type {?} */ version = parser.readVersion();
        var /** @type {?} */ ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
        // Read codewords
        var /** @type {?} */ codewords = parser.readCodewords();
        // Separate into data blocks
        var /** @type {?} */ dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);
        // Count total number of data bytes
        var /** @type {?} */ totalBytes = 0;
        for (var _i = 0, dataBlocks_1 = dataBlocks; _i < dataBlocks_1.length; _i++) {
            var dataBlock = dataBlocks_1[_i];
            totalBytes += dataBlock.getNumDataCodewords();
        }
        var /** @type {?} */ resultBytes = new Uint8Array(totalBytes);
        var /** @type {?} */ resultOffset = 0;
        // Error-correct and copy data blocks together into a stream of bytes
        for (var _a = 0, dataBlocks_2 = dataBlocks; _a < dataBlocks_2.length; _a++) {
            var dataBlock = dataBlocks_2[_a];
            var /** @type {?} */ codewordBytes = dataBlock.getCodewords();
            var /** @type {?} */ numDataCodewords = dataBlock.getNumDataCodewords();
            this.correctErrors(codewordBytes, numDataCodewords);
            for (var /** @type {?} */ i = 0; i < numDataCodewords; i++) {
                resultBytes[resultOffset++] = codewordBytes[i];
            }
        }
        // Decode the contents of that stream of bytes
        return DecodedBitStreamParser.decode(resultBytes, version, ecLevel, hints);
    };
    /**
     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
    correct the errors in-place using Reed-Solomon error correction.</p>
    
    \@param codewordBytes data and error correction codewords
    \@param numDataCodewords number of codewords that are data bytes
    \@throws ChecksumException if error correction fails
     * @param {?} codewordBytes
     * @param {?} numDataCodewords
     * @return {?}
     */
    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {
        var /** @type {?} */ codewordsInts = new Int32Array(codewordBytes);
        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?
        // const codewordsInts = new Int32Array(numCodewords)
        // for (let i = 0; i < numCodewords; i++) {
        //   codewordsInts[i] = codewordBytes[i] & 0xFF
        // }
        try {
            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        }
        catch (ignored /*: ReedSolomonException*/) {
            throw new Exception(Exception.ChecksumException);
        }
        // Copy back into array of bytes -- only need to worry about the bytes that were data
        // We don't care about errors in the error-correction codewords
        for (var /** @type {?} */ i = 0; i < numDataCodewords; i++) {
            codewordBytes[i] = codewordsInts[i];
        }
    };
    return Decoder;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw
matrix of black/white pixels corresponding to the barcode, and possibly points of interest
in the image, like the location of finder patterns or corners of the barcode in the image.</p>

\@author Sean Owen
 */
var DetectorResult = (function () {
    /**
     * @param {?} bits
     * @param {?} points
     */
    function DetectorResult(bits, points) {
        this.bits = bits;
        this.points = points;
    }
    /**
     * @return {?}
     */
    DetectorResult.prototype.getBits = function () {
        return this.bits;
    };
    /**
     * @return {?}
     */
    DetectorResult.prototype.getPoints = function () {
        return this.points;
    };
    return DetectorResult;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Implementations of this class can, given locations of finder patterns for a QR code in an
image, sample the right points in the image to reconstruct the QR code, accounting for
perspective distortion. It is abstracted since it is relatively expensive and should be allowed
to take advantage of platform-specific optimized implementations, like Sun's Java Advanced
Imaging library, but which may not be available in other environments such as J2ME, and vice
versa.

The implementation used can be controlled by calling {\@link #setGridSampler(GridSampler)}
with an instance of a class which implements this interface.

\@author Sean Owen
 * @abstract
 */
var GridSampler = (function () {
    function GridSampler() {
    }
    /**
     * Samples an image for a rectangular matrix of bits of the given dimension. The sampling
    transformation is determined by the coordinates of 4 points, in the original and transformed
    image space.
    
    \@param image image to sample
    \@param dimensionX width of {\@link BitMatrix} to sample from image
    \@param dimensionY height of {\@link BitMatrix} to sample from image
    \@param p1ToX point 1 preimage X
    \@param p1ToY point 1 preimage Y
    \@param p2ToX point 2 preimage X
    \@param p2ToY point 2 preimage Y
    \@param p3ToX point 3 preimage X
    \@param p3ToY point 3 preimage Y
    \@param p4ToX point 4 preimage X
    \@param p4ToY point 4 preimage Y
    \@param p1FromX point 1 image X
    \@param p1FromY point 1 image Y
    \@param p2FromX point 2 image X
    \@param p2FromY point 2 image Y
    \@param p3FromX point 3 image X
    \@param p3FromY point 3 image Y
    \@param p4FromX point 4 image X
    \@param p4FromY point 4 image Y
    \@return {\@link BitMatrix} representing a grid of points sampled from the image within a region
      defined by the "from" parameters
    \@throws NotFoundException if image can't be sampled, for example, if the transformation defined
      by the given points is invalid or results in sampling outside the image boundaries
     * @abstract
     * @param {?} image
     * @param {?} dimensionX
     * @param {?} dimensionY
     * @param {?} p1ToX
     * @param {?} p1ToY
     * @param {?} p2ToX
     * @param {?} p2ToY
     * @param {?} p3ToX
     * @param {?} p3ToY
     * @param {?} p4ToX
     * @param {?} p4ToY
     * @param {?} p1FromX
     * @param {?} p1FromY
     * @param {?} p2FromX
     * @param {?} p2FromY
     * @param {?} p3FromX
     * @param {?} p3FromY
     * @param {?} p4FromX
     * @param {?} p4FromY
     * @return {?}
     */
    GridSampler.prototype.sampleGrid = function (image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY) { };
    /**
     * @abstract
     * @param {?} image
     * @param {?} dimensionX
     * @param {?} dimensionY
     * @param {?} transform
     * @return {?}
     */
    GridSampler.prototype.sampleGridWithTransform = function (image, dimensionX /*int*/, dimensionY /*int*/, transform) { };
    /**
     * <p>Checks a set of points that have been transformed to sample points on an image against
    the image's dimensions to see if the point are even within the image.</p>
    
    <p>This method will actually "nudge" the endpoints back onto the image if they are found to be
    barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
    patterns in an image where the QR Code runs all the way to the image border.</p>
    
    <p>For efficiency, the method will check points from either end of the line until one is found
    to be within the image. Because the set of points are assumed to be linear, this is valid.</p>
    
    \@param image image into which the points should map
    \@param points actual points in x1,y1,...,xn,yn form
    \@throws NotFoundException if an endpoint is lies outside the image boundaries
     * @param {?} image
     * @param {?} points
     * @return {?}
     */
    GridSampler.checkAndNudgePoints = function (image, points) {
        var /** @type {?} */ width = image.getWidth();
        var /** @type {?} */ height = image.getHeight();
        // Check and nudge points from start until we see some that are OK:
        var /** @type {?} */ nudged = true;
        for (var /** @type {?} */ offset = 0; offset < points.length && nudged; offset += 2) {
            var /** @type {?} */ x = Math.floor(points[offset]);
            var /** @type {?} */ y = Math.floor(points[offset + 1]);
            if (x < -1 || x > width || y < -1 || y > height) {
                throw new Exception(Exception.NotFoundException);
            }
            nudged = false;
            if (x == -1) {
                points[offset] = 0.0;
                nudged = true;
            }
            else if (x == width) {
                points[offset] = width - 1;
                nudged = true;
            }
            if (y == -1) {
                points[offset + 1] = 0.0;
                nudged = true;
            }
            else if (y == height) {
                points[offset + 1] = height - 1;
                nudged = true;
            }
        }
        // Check and nudge points from end:
        nudged = true;
        for (var /** @type {?} */ offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
            var /** @type {?} */ x = Math.floor(points[offset]);
            var /** @type {?} */ y = Math.floor(points[offset + 1]);
            if (x < -1 || x > width || y < -1 || y > height) {
                throw new Exception(Exception.NotFoundException);
            }
            nudged = false;
            if (x == -1) {
                points[offset] = 0.0;
                nudged = true;
            }
            else if (x == width) {
                points[offset] = width - 1;
                nudged = true;
            }
            if (y == -1) {
                points[offset + 1] = 0.0;
                nudged = true;
            }
            else if (y == height) {
                points[offset + 1] = height - 1;
                nudged = true;
            }
        }
    };
    return GridSampler;
}());

/**
 * <p>This class implements a perspective transform in two dimensions. Given four source and four
destination points, it will compute the transformation implied between them. The code is based
directly upon section 3.4.2 of George Wolberg's "Digital Image Warping"; see pages 54-56.</p>

\@author Sean Owen
 */
var PerspectiveTransform = (function () {
    /**
     * @param {?} a11
     * @param {?} a21
     * @param {?} a31
     * @param {?} a12
     * @param {?} a22
     * @param {?} a32
     * @param {?} a13
     * @param {?} a23
     * @param {?} a33
     */
    function PerspectiveTransform(a11 /*float*/, a21 /*float*/, a31 /*float*/, a12 /*float*/, a22 /*float*/, a32 /*float*/, a13 /*float*/, a23 /*float*/, a33 /*float*/) {
        this.a11 = a11; /*float*/
        this.a21 = a21; /*float*/
        this.a31 = a31; /*float*/
        this.a12 = a12; /*float*/
        this.a22 = a22; /*float*/
        this.a32 = a32; /*float*/
        this.a13 = a13; /*float*/
        this.a23 = a23; /*float*/
        this.a33 = a33; /*float*/
    }
    /**
     * @param {?} x0
     * @param {?} y0
     * @param {?} x1
     * @param {?} y1
     * @param {?} x2
     * @param {?} y2
     * @param {?} x3
     * @param {?} y3
     * @param {?} x0p
     * @param {?} y0p
     * @param {?} x1p
     * @param {?} y1p
     * @param {?} x2p
     * @param {?} y2p
     * @param {?} x3p
     * @param {?} y3p
     * @return {?}
     */
    PerspectiveTransform.quadrilateralToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/, x0p /*float*/, y0p /*float*/, x1p /*float*/, y1p /*float*/, x2p /*float*/, y2p /*float*/, x3p /*float*/, y3p /*float*/) {
        var /** @type {?} */ qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
        var /** @type {?} */ sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
        return sToQ.times(qToS);
    };
    /**
     * @param {?} points
     * @return {?}
     */
    PerspectiveTransform.prototype.transformPoints = function (points) {
        var /** @type {?} */ max = points.length;
        var /** @type {?} */ a11 = this.a11;
        var /** @type {?} */ a12 = this.a12;
        var /** @type {?} */ a13 = this.a13;
        var /** @type {?} */ a21 = this.a21;
        var /** @type {?} */ a22 = this.a22;
        var /** @type {?} */ a23 = this.a23;
        var /** @type {?} */ a31 = this.a31;
        var /** @type {?} */ a32 = this.a32;
        var /** @type {?} */ a33 = this.a33;
        for (var /** @type {?} */ i = 0; i < max; i += 2) {
            var /** @type {?} */ x = points[i];
            var /** @type {?} */ y = points[i + 1];
            var /** @type {?} */ denominator = a13 * x + a23 * y + a33;
            points[i] = (a11 * x + a21 * y + a31) / denominator;
            points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
        }
    };
    /**
     * @param {?} xValues
     * @param {?} yValues
     * @return {?}
     */
    PerspectiveTransform.prototype.transformPointsWithValues = function (xValues, yValues) {
        var /** @type {?} */ a11 = this.a11;
        var /** @type {?} */ a12 = this.a12;
        var /** @type {?} */ a13 = this.a13;
        var /** @type {?} */ a21 = this.a21;
        var /** @type {?} */ a22 = this.a22;
        var /** @type {?} */ a23 = this.a23;
        var /** @type {?} */ a31 = this.a31;
        var /** @type {?} */ a32 = this.a32;
        var /** @type {?} */ a33 = this.a33;
        var /** @type {?} */ n = xValues.length;
        for (var /** @type {?} */ i = 0; i < n; i++) {
            var /** @type {?} */ x = xValues[i];
            var /** @type {?} */ y = yValues[i];
            var /** @type {?} */ denominator = a13 * x + a23 * y + a33;
            xValues[i] = (a11 * x + a21 * y + a31) / denominator;
            yValues[i] = (a12 * x + a22 * y + a32) / denominator;
        }
    };
    /**
     * @param {?} x0
     * @param {?} y0
     * @param {?} x1
     * @param {?} y1
     * @param {?} x2
     * @param {?} y2
     * @param {?} x3
     * @param {?} y3
     * @return {?}
     */
    PerspectiveTransform.squareToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {
        var /** @type {?} */ dx3 = x0 - x1 + x2 - x3;
        var /** @type {?} */ dy3 = y0 - y1 + y2 - y3;
        if (dx3 === 0.0 && dy3 === 0.0) {
            // Affine
            return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);
        }
        else {
            var /** @type {?} */ dx1 = x1 - x2;
            var /** @type {?} */ dx2 = x3 - x2;
            var /** @type {?} */ dy1 = y1 - y2;
            var /** @type {?} */ dy2 = y3 - y2;
            var /** @type {?} */ denominator = dx1 * dy2 - dx2 * dy1;
            var /** @type {?} */ a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
            var /** @type {?} */ a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
            return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);
        }
    };
    /**
     * @param {?} x0
     * @param {?} y0
     * @param {?} x1
     * @param {?} y1
     * @param {?} x2
     * @param {?} y2
     * @param {?} x3
     * @param {?} y3
     * @return {?}
     */
    PerspectiveTransform.quadrilateralToSquare = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {
        // Here, the adjoint serves as the inverse:
        return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
    };
    /**
     * @return {?}
     */
    PerspectiveTransform.prototype.buildAdjoint = function () {
        // Adjoint is the transpose of the cofactor matrix:
        return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
    };
    /**
     * @param {?} other
     * @return {?}
     */
    PerspectiveTransform.prototype.times = function (other) {
        return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
    };
    return PerspectiveTransform;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*namespace com.google.zxing.common {*/
/**
 * @author Sean Owen
 */
var DefaultGridSampler = (function (_super) {
    __extends$5(DefaultGridSampler, _super);
    function DefaultGridSampler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} image
     * @param {?} dimensionX
     * @param {?} dimensionY
     * @param {?} p1ToX
     * @param {?} p1ToY
     * @param {?} p2ToX
     * @param {?} p2ToY
     * @param {?} p3ToX
     * @param {?} p3ToY
     * @param {?} p4ToX
     * @param {?} p4ToY
     * @param {?} p1FromX
     * @param {?} p1FromY
     * @param {?} p2FromX
     * @param {?} p2FromY
     * @param {?} p3FromX
     * @param {?} p3FromY
     * @param {?} p4FromX
     * @param {?} p4FromY
     * @return {?}
     */
    DefaultGridSampler.prototype.sampleGrid = function (image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY /*float*/) {
        var /** @type {?} */ transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
    };
    /**
     * @param {?} image
     * @param {?} dimensionX
     * @param {?} dimensionY
     * @param {?} transform
     * @return {?}
     */
    DefaultGridSampler.prototype.sampleGridWithTransform = function (image, dimensionX /*int*/, dimensionY /*int*/, transform) {
        if (dimensionX <= 0 || dimensionY <= 0) {
            throw new Exception(Exception.NotFoundException);
        }
        var /** @type {?} */ bits = new BitMatrix(dimensionX, dimensionY);
        var /** @type {?} */ points = new Float32Array(2 * dimensionX);
        for (var /** @type {?} */ y = 0; y < dimensionY; y++) {
            var /** @type {?} */ max = points.length;
            var /** @type {?} */ iValue = y + 0.5;
            for (var /** @type {?} */ x = 0; x < max; x += 2) {
                points[x] = (x / 2) + 0.5;
                points[x + 1] = iValue;
            }
            transform.transformPoints(points);
            // Quick check to see if points transformed to something inside the image
            // sufficient to check the endpoints
            GridSampler.checkAndNudgePoints(image, points);
            try {
                for (var /** @type {?} */ x = 0; x < max; x += 2) {
                    if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {
                        // Black(-ish) pixel
                        bits.set(x / 2, y);
                    }
                }
            }
            catch (aioobe /*: ArrayIndexOutOfBoundsException*/) {
                // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting
                // transform gets "twisted" such that it maps a straight line of points to a set of points
                // whose endpoints are in bounds, but others are not. There is probably some mathematical
                // way to detect this about the transformation that I don't know yet.
                // This results in an ugly runtime exception despite our clever checks above -- can't have
                // that. We could check each point's coordinates but that feels duplicative. We settle for
                // catching and wrapping ArrayIndexOutOfBoundsException.
                throw new Exception(Exception.NotFoundException);
            }
        }
        return bits;
    };
    return DefaultGridSampler;
}(GridSampler));

var GridSamplerInstance = (function () {
    function GridSamplerInstance() {
    }
    /**
     * Sets the implementation of GridSampler used by the library. One global
    instance is stored, which may sound problematic. But, the implementation provided
    ought to be appropriate for the entire platform, and all uses of this library
    in the whole lifetime of the JVM. For instance, an Android activity can swap in
    an implementation that takes advantage of native platform libraries.
    
    \@param newGridSampler The platform-specific object to install.
     * @param {?} newGridSampler
     * @return {?}
     */
    GridSamplerInstance.setGridSampler = function (newGridSampler) {
        GridSamplerInstance.gridSampler = newGridSampler;
    };
    /**
     * @return {?} the current implementation of GridSampler
     */
    GridSamplerInstance.getInstance = function () {
        return GridSamplerInstance.gridSampler;
    };
    return GridSamplerInstance;
}());
GridSamplerInstance.gridSampler = new DefaultGridSampler();

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*namespace com.google.zxing.qrcode.detector {*/
/**
 * <p>Encapsulates a finder pattern, which are the three square patterns found in
the corners of QR Codes. It also encapsulates a count of similar finder patterns,
as a convenience to the finder's bookkeeping.</p>

\@author Sean Owen
 */
var FinderPattern = (function (_super) {
    __extends$6(FinderPattern, _super);
    /**
     * @param {?} posX
     * @param {?} posY
     * @param {?} estimatedModuleSize
     * @param {?=} count
     */
    function FinderPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {
        var _this = _super.call(this, posX, posY) || this;
        _this.estimatedModuleSize = estimatedModuleSize; /*float*/
        _this.count = count; /*int*/
        if (undefined === count) {
            _this.count = 1;
        }
        return _this;
    }
    /**
     * @return {?}
     */
    FinderPattern.prototype.getEstimatedModuleSize = function () {
        return this.estimatedModuleSize;
    };
    /**
     * @return {?}
     */
    FinderPattern.prototype.getCount = function () {
        return this.count;
    };
    /**
     * <p>Determines if this finder pattern "about equals" a finder pattern at the stated
    position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
     * @param {?} moduleSize
     * @param {?} i
     * @param {?} j
     * @return {?}
     */
    FinderPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {
        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
            var /** @type {?} */ moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
    };
    /**
     * Combines this object's current estimate of a finder pattern position and module size
    with a new estimate. It returns a new {\@code FinderPattern} containing a weighted average
    based on count.
     * @param {?} i
     * @param {?} j
     * @param {?} newModuleSize
     * @return {?}
     */
    FinderPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {
        var /** @type {?} */ combinedCount = this.count + 1;
        var /** @type {?} */ combinedX = (this.count * this.getX() + j) / combinedCount;
        var /** @type {?} */ combinedY = (this.count * this.getY() + i) / combinedCount;
        var /** @type {?} */ combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
        return new FinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);
    };
    return FinderPattern;
}(ResultPoint));

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>Encapsulates information about finder patterns in an image, including the location of
the three finder patterns, and their estimated module size.</p>

\@author Sean Owen
 */
var FinderPatternInfo = (function () {
    /**
     * @param {?} patternCenters
     */
    function FinderPatternInfo(patternCenters) {
        this.bottomLeft = patternCenters[0];
        this.topLeft = patternCenters[1];
        this.topRight = patternCenters[2];
    }
    /**
     * @return {?}
     */
    FinderPatternInfo.prototype.getBottomLeft = function () {
        return this.bottomLeft;
    };
    /**
     * @return {?}
     */
    FinderPatternInfo.prototype.getTopLeft = function () {
        return this.topLeft;
    };
    /**
     * @return {?}
     */
    FinderPatternInfo.prototype.getTopRight = function () {
        return this.topRight;
    };
    return FinderPatternInfo;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square
markers at three corners of a QR Code.</p>

<p>This class is thread-safe but not reentrant. Each thread must allocate its own object.

\@author Sean Owen
 */
var FinderPatternFinder = (function () {
    /**
     * @param {?} image
     * @param {?} resultPointCallback
     */
    function FinderPatternFinder(image, resultPointCallback) {
        this.image = image;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(5);
        this.resultPointCallback = resultPointCallback;
    }
    /**
     * @return {?}
     */
    FinderPatternFinder.prototype.getImage = function () {
        return this.image;
    };
    /**
     * @return {?}
     */
    FinderPatternFinder.prototype.getPossibleCenters = function () {
        return this.possibleCenters;
    };
    /**
     * @param {?} hints
     * @return {?}
     */
    FinderPatternFinder.prototype.find = function (hints) {
        var /** @type {?} */ tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(3 /* TRY_HARDER */);
        var /** @type {?} */ pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(1 /* PURE_BARCODE */);
        var /** @type {?} */ image = this.image;
        var /** @type {?} */ maxI = image.getHeight();
        var /** @type {?} */ maxJ = image.getWidth();
        // We are looking for black/white/black/white/black modules in
        // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far
        // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the
        // image, and then account for the center being 3 modules in size. This gives the smallest
        // number of pixels the center could be, so skip this often. When trying harder, look for all
        // QR versions regardless of how dense they are.
        var /** @type {?} */ iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));
        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
            iSkip = FinderPatternFinder.MIN_SKIP;
        }
        var /** @type {?} */ done = false;
        var /** @type {?} */ stateCount = new Int32Array(5);
        for (var /** @type {?} */ i = iSkip - 1; i < maxI && !done; i += iSkip) {
            // Get a row of black/white values
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            stateCount[3] = 0;
            stateCount[4] = 0;
            var /** @type {?} */ currentState = 0;
            for (var /** @type {?} */ j = 0; j < maxJ; j++) {
                if (image.get(j, i)) {
                    // Black pixel
                    if ((currentState & 1) === 1) {
                        currentState++;
                    }
                    stateCount[currentState]++;
                }
                else {
                    if ((currentState & 1) === 0) {
                        if (currentState === 4) {
                            if (FinderPatternFinder.foundPatternCross(stateCount)) {
                                var /** @type {?} */ confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);
                                if (confirmed === true) {
                                    // Start examining every other line. Checking each line turned out to be too
                                    // expensive and didn't improve performance.
                                    iSkip = 2;
                                    if (this.hasSkipped === true) {
                                        done = this.haveMultiplyConfirmedCenters();
                                    }
                                    else {
                                        var /** @type {?} */ rowSkip = this.findRowSkip();
                                        if (rowSkip > stateCount[2]) {
                                            // Skip rows between row of lower confirmed center
                                            // and top of presumed third confirmed center
                                            // but back up a bit to get a full chance of detecting
                                            // it, entire width of center of finder pattern
                                            // Skip by rowSkip, but back off by stateCount[2] (size of last center
                                            // of pattern we saw) to be conservative, and also back off by iSkip which
                                            // is about to be re-added
                                            i += rowSkip - stateCount[2] - iSkip;
                                            j = maxJ - 1;
                                        }
                                    }
                                }
                                else {
                                    stateCount[0] = stateCount[2];
                                    stateCount[1] = stateCount[3];
                                    stateCount[2] = stateCount[4];
                                    stateCount[3] = 1;
                                    stateCount[4] = 0;
                                    currentState = 3;
                                    continue;
                                }
                                // Clear state to start looking again
                                currentState = 0;
                                stateCount[0] = 0;
                                stateCount[1] = 0;
                                stateCount[2] = 0;
                                stateCount[3] = 0;
                                stateCount[4] = 0;
                            }
                            else {
                                stateCount[0] = stateCount[2];
                                stateCount[1] = stateCount[3];
                                stateCount[2] = stateCount[4];
                                stateCount[3] = 1;
                                stateCount[4] = 0;
                                currentState = 3;
                            }
                        }
                        else {
                            stateCount[++currentState]++;
                        }
                    }
                    else {
                        stateCount[currentState]++;
                    }
                }
            }
            if (FinderPatternFinder.foundPatternCross(stateCount)) {
                var /** @type {?} */ confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);
                if (confirmed === true) {
                    iSkip = stateCount[0];
                    if (this.hasSkipped) {
                        // Found a third one
                        done = this.haveMultiplyConfirmedCenters();
                    }
                }
            }
        }
        var /** @type {?} */ patternInfo = this.selectBestPatterns();
        ResultPoint.orderBestPatterns(patternInfo);
        return new FinderPatternInfo(patternInfo);
    };
    /**
     * Given a count of black/white/black/white/black pixels just seen and an end position,
    figures the location of the center of this run.
     * @param {?} stateCount
     * @param {?} end
     * @return {?}
     */
    FinderPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {
        return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;
    };
    /**
     * @param {?} stateCount count of black/white/black/white/black pixels just read
     * @return {?}
     */
    FinderPatternFinder.foundPatternCross = function (stateCount) {
        var /** @type {?} */ totalModuleSize = 0;
        for (var /** @type {?} */ i = 0; i < 5; i++) {
            var /** @type {?} */ count = stateCount[i];
            if (count === 0) {
                return false;
            }
            totalModuleSize += count;
        }
        if (totalModuleSize < 7) {
            return false;
        }
        var /** @type {?} */ moduleSize = totalModuleSize / 7.0;
        var /** @type {?} */ maxVariance = moduleSize / 2.0;
        // Allow less than 50% variance from 1-1-3-1-1 proportions
        return Math.abs(moduleSize - stateCount[0]) < maxVariance &&
            Math.abs(moduleSize - stateCount[1]) < maxVariance &&
            Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&
            Math.abs(moduleSize - stateCount[3]) < maxVariance &&
            Math.abs(moduleSize - stateCount[4]) < maxVariance;
    };
    /**
     * @return {?}
     */
    FinderPatternFinder.prototype.getCrossCheckStateCount = function () {
        var /** @type {?} */ crossCheckStateCount = this.crossCheckStateCount;
        crossCheckStateCount[0] = 0;
        crossCheckStateCount[1] = 0;
        crossCheckStateCount[2] = 0;
        crossCheckStateCount[3] = 0;
        crossCheckStateCount[4] = 0;
        return crossCheckStateCount;
    };
    /**
     * After a vertical and horizontal scan finds a potential finder pattern, this method
    "cross-cross-cross-checks" by scanning down diagonally through the center of the possible
    finder pattern to see if the same proportion is detected.
    
    \@param startI row where a finder pattern was detected
    \@param centerJ center of the section that appears to cross a finder pattern
    \@param maxCount maximum reasonable number of modules that should be
     observed in any reading state, based on the results of the horizontal scan
    \@param originalStateCountTotal The original state count total.
    \@return true if proportions are withing expected limits
     * @param {?} startI
     * @param {?} centerJ
     * @param {?} maxCount
     * @param {?} originalStateCountTotal
     * @return {?}
     */
    FinderPatternFinder.prototype.crossCheckDiagonal = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
        var /** @type {?} */ stateCount = this.getCrossCheckStateCount();
        // Start counting up, left from center finding black center mass
        var /** @type {?} */ i = 0;
        var /** @type {?} */ image = this.image;
        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {
            stateCount[2]++;
            i++;
        }
        if (startI < i || centerJ < i) {
            return false;
        }
        // Continue up, left finding white space
        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&
            stateCount[1] <= maxCount) {
            stateCount[1]++;
            i++;
        }
        // If already too many modules in this state or ran off the edge:
        if (startI < i || centerJ < i || stateCount[1] > maxCount) {
            return false;
        }
        // Continue up, left finding black border
        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&
            stateCount[0] <= maxCount) {
            stateCount[0]++;
            i++;
        }
        if (stateCount[0] > maxCount) {
            return false;
        }
        var /** @type {?} */ maxI = image.getHeight();
        var /** @type {?} */ maxJ = image.getWidth();
        // Now also count down, right from center
        i = 1;
        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {
            stateCount[2]++;
            i++;
        }
        // Ran off the edge?
        if (startI + i >= maxI || centerJ + i >= maxJ) {
            return false;
        }
        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&
            stateCount[3] < maxCount) {
            stateCount[3]++;
            i++;
        }
        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {
            return false;
        }
        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&
            stateCount[4] < maxCount) {
            stateCount[4]++;
            i++;
        }
        if (stateCount[4] >= maxCount) {
            return false;
        }
        // If we found a finder-pattern-like section, but its size is more than 100% different than
        // the original, assume it's a false positive
        var /** @type {?} */ stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&
            FinderPatternFinder.foundPatternCross(stateCount);
    };
    /**
     * <p>After a horizontal scan finds a potential finder pattern, this method
    "cross-checks" by scanning down vertically through the center of the possible
    finder pattern to see if the same proportion is detected.</p>
    
    \@param startI row where a finder pattern was detected
    \@param centerJ center of the section that appears to cross a finder pattern
    \@param maxCount maximum reasonable number of modules that should be
    observed in any reading state, based on the results of the horizontal scan
    \@return vertical center of finder pattern, or {\@link Float#NaN} if not found
     * @param {?} startI
     * @param {?} centerJ
     * @param {?} maxCount
     * @param {?} originalStateCountTotal
     * @return {?}
     */
    FinderPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
        var /** @type {?} */ image = this.image;
        var /** @type {?} */ maxI = image.getHeight();
        var /** @type {?} */ stateCount = this.getCrossCheckStateCount();
        // Start counting up from center
        var /** @type {?} */ i = startI;
        while (i >= 0 && image.get(centerJ, i)) {
            stateCount[2]++;
            i--;
        }
        if (i < 0) {
            return NaN;
        }
        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i--;
        }
        // If already too many modules in this state or ran off the edge:
        if (i < 0 || stateCount[1] > maxCount) {
            return NaN;
        }
        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i--;
        }
        if (stateCount[0] > maxCount) {
            return NaN;
        }
        // Now also count down from center
        i = startI + 1;
        while (i < maxI && image.get(centerJ, i)) {
            stateCount[2]++;
            i++;
        }
        if (i === maxI) {
            return NaN;
        }
        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {
            stateCount[3]++;
            i++;
        }
        if (i === maxI || stateCount[3] >= maxCount) {
            return NaN;
        }
        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {
            stateCount[4]++;
            i++;
        }
        if (stateCount[4] >= maxCount) {
            return NaN;
        }
        // If we found a finder-pattern-like section, but its size is more than 40% different than
        // the original, assume it's a false positive
        var /** @type {?} */ stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
            stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
            return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;
    };
    /**
     * <p>Like {\@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,
    except it reads horizontally instead of vertically. This is used to cross-cross
    check a vertical cross check and locate the real center of the alignment pattern.</p>
     * @param {?} startJ
     * @param {?} centerI
     * @param {?} maxCount
     * @param {?} originalStateCountTotal
     * @return {?}
     */
    FinderPatternFinder.prototype.crossCheckHorizontal = function (startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
        var /** @type {?} */ image = this.image;
        var /** @type {?} */ maxJ = image.getWidth();
        var /** @type {?} */ stateCount = this.getCrossCheckStateCount();
        var /** @type {?} */ j = startJ;
        while (j >= 0 && image.get(j, centerI)) {
            stateCount[2]++;
            j--;
        }
        if (j < 0) {
            return NaN;
        }
        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            j--;
        }
        if (j < 0 || stateCount[1] > maxCount) {
            return NaN;
        }
        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            j--;
        }
        if (stateCount[0] > maxCount) {
            return NaN;
        }
        j = startJ + 1;
        while (j < maxJ && image.get(j, centerI)) {
            stateCount[2]++;
            j++;
        }
        if (j == maxJ) {
            return NaN;
        }
        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
            stateCount[3]++;
            j++;
        }
        if (j == maxJ || stateCount[3] >= maxCount) {
            return NaN;
        }
        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
            stateCount[4]++;
            j++;
        }
        if (stateCount[4] >= maxCount) {
            return NaN;
        }
        // If we found a finder-pattern-like section, but its size is significantly different than
        // the original, assume it's a false positive
        var /** @type {?} */ stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
            stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
            return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;
    };
    /**
     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
    cross check with a vertical scan, and if successful, will, ah, cross-cross-check
    with another horizontal scan. This is needed primarily to locate the real horizontal
    center of the pattern in cases of extreme skew.
    And then we cross-cross-cross check with another diagonal scan.</p>
    
    <p>If that succeeds the finder pattern location is added to a list that tracks
    the number of times each location has been nearly-matched as a finder pattern.
    Each additional find is more evidence that the location is in fact a finder
    pattern center
    
    \@param stateCount reading state module counts from horizontal scan
    \@param i row where finder pattern may be found
    \@param j end of possible finder pattern in row
    \@param pureBarcode true if in "pure barcode" mode
    \@return true if a finder pattern candidate was found this time
     * @param {?} stateCount
     * @param {?} i
     * @param {?} j
     * @param {?} pureBarcode
     * @return {?}
     */
    FinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/, pureBarcode) {
        var /** @type {?} */ stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
            stateCount[4];
        var /** @type {?} */ centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);
        var /** @type {?} */ centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);
        if (!isNaN(centerI)) {
            // Re-cross check
            centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);
            if (!isNaN(centerJ) &&
                (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {
                var /** @type {?} */ estimatedModuleSize = stateCountTotal / 7.0;
                var /** @type {?} */ found = false;
                var /** @type {?} */ possibleCenters = this.possibleCenters;
                for (var /** @type {?} */ index = 0, /** @type {?} */ length_1 = possibleCenters.length; index < length_1; index++) {
                    var /** @type {?} */ center = possibleCenters[index];
                    // Look for about the same center and module size:
                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                        possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    var /** @type {?} */ point = new FinderPattern(centerJ, centerI, estimatedModuleSize);
                    possibleCenters.push(point);
                    if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {
                        this.resultPointCallback.foundPossibleResultPoint(point);
                    }
                }
                return true;
            }
        }
        return false;
    };
    /**
     * @return {?} number of rows we could safely skip during scanning, based on the first
     */
    FinderPatternFinder.prototype.findRowSkip = function () {
        var /** @type {?} */ max = this.possibleCenters.length;
        if (max <= 1) {
            return 0;
        }
        var /** @type {?} */ firstConfirmedCenter = null;
        for (var _i = 0, _a = this.possibleCenters; _i < _a.length; _i++) {
            var center = _a[_i];
            if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
                if (firstConfirmedCenter == null) {
                    firstConfirmedCenter = center;
                }
                else {
                    // We have two confirmed centers
                    // How far down can we skip before resuming looking for the next
                    // pattern? In the worst case, only the difference between the
                    // difference in the x / y coordinates of the two centers.
                    // This is the case where you find top left last.
                    this.hasSkipped = true;
                    return Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -
                        Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);
                }
            }
        }
        return 0;
    };
    /**
     * @return {?} true iff we have found at least 3 finder patterns that have been detected
     */
    FinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {
        var /** @type {?} */ confirmedCount = 0;
        var /** @type {?} */ totalModuleSize = 0.0;
        var /** @type {?} */ max = this.possibleCenters.length;
        for (var _i = 0, _a = this.possibleCenters; _i < _a.length; _i++) {
            var pattern = _a[_i];
            if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
                confirmedCount++;
                totalModuleSize += pattern.getEstimatedModuleSize();
            }
        }
        if (confirmedCount < 3) {
            return false;
        }
        // OK, we have at least 3 confirmed centers, but, it's possible that one is a "false positive"
        // and that we need to keep looking. We detect this by asking if the estimated module sizes
        // vary too much. We arbitrarily say that when the total deviation from average exceeds
        // 5% of the total module size estimates, it's too much.
        var /** @type {?} */ average = totalModuleSize / max;
        var /** @type {?} */ totalDeviation = 0.0;
        for (var _b = 0, _c = this.possibleCenters; _b < _c.length; _b++) {
            var pattern = _c[_b];
            totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
        }
        return totalDeviation <= 0.05 * totalModuleSize;
    };
    /**
     * @return {?} the 3 best {\@link FinderPattern}s from our list of candidates. The "best" are
     */
    FinderPatternFinder.prototype.selectBestPatterns = function () {
        var /** @type {?} */ startSize = this.possibleCenters.length;
        if (startSize < 3) {
            // Couldn't find enough finder patterns
            throw new Exception(Exception.NotFoundException);
        }
        var /** @type {?} */ possibleCenters = this.possibleCenters;
        var /** @type {?} */ average; /*float*/
        // Filter outlier possibilities whose module size is too different
        if (startSize > 3) {
            // But we can only afford to do so if we have at least 4 possibilities to choose from
            var /** @type {?} */ totalModuleSize = 0.0;
            var /** @type {?} */ square = 0.0;
            for (var _i = 0, _a = this.possibleCenters; _i < _a.length; _i++) {
                var center = _a[_i];
                var /** @type {?} */ size = center.getEstimatedModuleSize();
                totalModuleSize += size;
                square += size * size;
            }
            average = totalModuleSize / startSize;
            var /** @type {?} */ stdDev = Math.sqrt(square / startSize - average * average);
            possibleCenters.sort(
            /**
             * <p>Orders by furthest from average</p>
             */
            // FurthestFromAverageComparator implements Comparator<FinderPattern>
            function (center1, center2) {
                var /** @type {?} */ dA = Math.abs(center2.getEstimatedModuleSize() - average);
                var /** @type {?} */ dB = Math.abs(center1.getEstimatedModuleSize() - average);
                return dA < dB ? -1 : dA > dB ? 1 : 0;
            });
            var /** @type {?} */ limit = Math.max(0.2 * average, stdDev);
            for (var /** @type {?} */ i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {
                var /** @type {?} */ pattern = possibleCenters[i];
                if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
                    possibleCenters.splice(i, 1);
                    i--;
                }
            }
        }
        if (possibleCenters.length > 3) {
            // Throw away all but those first size candidate points we found.
            var /** @type {?} */ totalModuleSize = 0.0;
            for (var _b = 0, possibleCenters_1 = possibleCenters; _b < possibleCenters_1.length; _b++) {
                var possibleCenter = possibleCenters_1[_b];
                totalModuleSize += possibleCenter.getEstimatedModuleSize();
            }
            average = totalModuleSize / possibleCenters.length;
            possibleCenters.sort(
            /**
             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
             */
            // CenterComparator implements Comparator<FinderPattern>
            function (center1, center2) {
                if (center2.getCount() === center1.getCount()) {
                    var /** @type {?} */ dA = Math.abs(center2.getEstimatedModuleSize() - average);
                    var /** @type {?} */ dB = Math.abs(center1.getEstimatedModuleSize() - average);
                    return dA < dB ? 1 : dA > dB ? -1 : 0;
                }
                else {
                    return center2.getCount() - center1.getCount();
                }
            });
            possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway
        }
        return [
            possibleCenters[0],
            possibleCenters[1],
            possibleCenters[2]
        ];
    };
    return FinderPatternFinder;
}());
FinderPatternFinder.CENTER_QUORUM = 2;
FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center
FinderPatternFinder.MAX_MODULES = 57;

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*namespace com.google.zxing.qrcode.detector {*/
/**
 * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in
all but the simplest QR Codes.</p>

\@author Sean Owen
 */
var AlignmentPattern = (function (_super) {
    __extends$7(AlignmentPattern, _super);
    /**
     * @param {?} posX
     * @param {?} posY
     * @param {?} estimatedModuleSize
     */
    function AlignmentPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/) {
        var _this = _super.call(this, posX, posY) || this;
        _this.estimatedModuleSize = estimatedModuleSize; /*float*/
        return _this;
    }
    /**
     * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated
    position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
     * @param {?} moduleSize
     * @param {?} i
     * @param {?} j
     * @return {?}
     */
    AlignmentPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {
        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
            var /** @type {?} */ moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
    };
    /**
     * Combines this object's current estimate of a finder pattern position and module size
    with a new estimate. It returns a new {\@code FinderPattern} containing an average of the two.
     * @param {?} i
     * @param {?} j
     * @param {?} newModuleSize
     * @return {?}
     */
    AlignmentPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {
        var /** @type {?} */ combinedX = (this.getX() + j) / 2.0;
        var /** @type {?} */ combinedY = (this.getY() + i) / 2.0;
        var /** @type {?} */ combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;
        return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
    };
    return AlignmentPattern;
}(ResultPoint));

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder
patterns but are smaller and appear at regular intervals throughout the image.</p>

<p>At the moment this only looks for the bottom-right alignment pattern.</p>

<p>This is mostly a simplified copy of {\@link FinderPatternFinder}. It is copied,
pasted and stripped down here for maximum performance but does unfortunately duplicate
some code.</p>

<p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>

\@author Sean Owen
 */
var AlignmentPatternFinder = (function () {
    /**
     * <p>Creates a finder that will look in a portion of the whole image.</p>
    
    \@param image image to search
    \@param startX left column from which to start searching
    \@param startY top row from which to start searching
    \@param width width of region to search
    \@param height height of region to search
    \@param moduleSize estimated module size so far
     * @param {?} image
     * @param {?} startX
     * @param {?} startY
     * @param {?} width
     * @param {?} height
     * @param {?} moduleSize
     * @param {?} resultPointCallback
     */
    function AlignmentPatternFinder(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {
        this.image = image;
        this.startX = startX; /*int*/
        this.startY = startY; /*int*/
        this.width = width; /*int*/
        this.height = height; /*int*/
        this.moduleSize = moduleSize; /*float*/
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = []; //new Array<any>(5)
        // TYPESCRIPTPORT: array initialization without size as the length is checked below
        this.crossCheckStateCount = new Int32Array(3);
    }
    /**
     * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since
    it's pretty performance-critical and so is written to be fast foremost.</p>
    
    \@return {\@link AlignmentPattern} if found
    \@throws NotFoundException if not found
     * @return {?}
     */
    AlignmentPatternFinder.prototype.find = function () {
        var /** @type {?} */ startX = this.startX;
        var /** @type {?} */ height = this.height;
        var /** @type {?} */ width = this.width;
        var /** @type {?} */ maxJ = startX + width;
        var /** @type {?} */ middleI = this.startY + (height / 2);
        // We are looking for black/white/black modules in 1:1:1 ratio
        // this tracks the number of black/white/black modules seen so far
        var /** @type {?} */ stateCount = new Int32Array(3);
        var /** @type {?} */ image = this.image;
        for (var /** @type {?} */ iGen = 0; iGen < height; iGen++) {
            // Search from middle outwards
            var /** @type {?} */ i = middleI + ((iGen & 0x01) == 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            var /** @type {?} */ j = startX;
            // Burn off leading white pixels before anything else; if we start in the middle of
            // a white run, it doesn't make sense to count its length, since we don't know if the
            // white run continued to the left of the start point
            while (j < maxJ && !image.get(j, i)) {
                j++;
            }
            var /** @type {?} */ currentState = 0;
            while (j < maxJ) {
                if (image.get(j, i)) {
                    // Black pixel
                    if (currentState === 1) {
                        stateCount[1]++;
                    }
                    else {
                        if (currentState === 2) {
                            if (this.foundPatternCross(stateCount)) {
                                var /** @type {?} */ confirmed = this.handlePossibleCenter(stateCount, i, j);
                                if (confirmed !== null) {
                                    return confirmed;
                                }
                            }
                            stateCount[0] = stateCount[2];
                            stateCount[1] = 1;
                            stateCount[2] = 0;
                            currentState = 1;
                        }
                        else {
                            stateCount[++currentState]++;
                        }
                    }
                }
                else {
                    if (currentState === 1) {
                        currentState++;
                    }
                    stateCount[currentState]++;
                }
                j++;
            }
            if (this.foundPatternCross(stateCount)) {
                var /** @type {?} */ confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
                if (confirmed !== null) {
                    return confirmed;
                }
            }
        }
        // Hmm, nothing we saw was observed and confirmed twice. If we had
        // any guess at all, return it.
        if (this.possibleCenters.length !== 0) {
            return this.possibleCenters[0];
        }
        throw new Exception(Exception.NotFoundException);
    };
    /**
     * Given a count of black/white/black pixels just seen and an end position,
    figures the location of the center of this black/white/black run.
     * @param {?} stateCount
     * @param {?} end
     * @return {?}
     */
    AlignmentPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {
        return (end - stateCount[2]) - stateCount[1] / 2.0;
    };
    /**
     * @param {?} stateCount count of black/white/black pixels just read
     * @return {?}
     */
    AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {
        var /** @type {?} */ moduleSize = this.moduleSize;
        var /** @type {?} */ maxVariance = moduleSize / 2.0;
        for (var /** @type {?} */ i = 0; i < 3; i++) {
            if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
                return false;
            }
        }
        return true;
    };
    /**
     * <p>After a horizontal scan finds a potential alignment pattern, this method
    "cross-checks" by scanning down vertically through the center of the possible
    alignment pattern to see if the same proportion is detected.</p>
    
    \@param startI row where an alignment pattern was detected
    \@param centerJ center of the section that appears to cross an alignment pattern
    \@param maxCount maximum reasonable number of modules that should be
    observed in any reading state, based on the results of the horizontal scan
    \@return vertical center of alignment pattern, or {\@link Float#NaN} if not found
     * @param {?} startI
     * @param {?} centerJ
     * @param {?} maxCount
     * @param {?} originalStateCountTotal
     * @return {?}
     */
    AlignmentPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
        var /** @type {?} */ image = this.image;
        var /** @type {?} */ maxI = image.getHeight();
        var /** @type {?} */ stateCount = this.crossCheckStateCount;
        stateCount[0] = 0;
        stateCount[1] = 0;
        stateCount[2] = 0;
        // Start counting up from center
        var /** @type {?} */ i = startI;
        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i--;
        }
        // If already too many modules in this state or ran off the edge:
        if (i < 0 || stateCount[1] > maxCount) {
            return NaN;
        }
        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i--;
        }
        if (stateCount[0] > maxCount) {
            return NaN;
        }
        // Now also count down from center
        i = startI + 1;
        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i++;
        }
        if (i == maxI || stateCount[1] > maxCount) {
            return NaN;
        }
        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {
            stateCount[2]++;
            i++;
        }
        if (stateCount[2] > maxCount) {
            return NaN;
        }
        var /** @type {?} */ stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
            return NaN;
        }
        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;
    };
    /**
     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
    cross check with a vertical scan, and if successful, will see if this pattern had been
    found on a previous horizontal scan. If so, we consider it confirmed and conclude we have
    found the alignment pattern.</p>
    
    \@param stateCount reading state module counts from horizontal scan
    \@param i row where alignment pattern may be found
    \@param j end of possible alignment pattern in row
    \@return {\@link AlignmentPattern} if we have found the same pattern twice, or null if not
     * @param {?} stateCount
     * @param {?} i
     * @param {?} j
     * @return {?}
     */
    AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/) {
        var /** @type {?} */ stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        var /** @type {?} */ centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);
        var /** @type {?} */ centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);
        if (!isNaN(centerI)) {
            var /** @type {?} */ estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;
            for (var _i = 0, _a = this.possibleCenters; _i < _a.length; _i++) {
                var center = _a[_i];
                // Look for about the same center and module size:
                if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                    return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                }
            }
            // Hadn't found this before; save it
            var /** @type {?} */ point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
            this.possibleCenters.push(point);
            if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {
                this.resultPointCallback.foundPossibleResultPoint(point);
            }
        }
        return null;
    };
    return AlignmentPatternFinder;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code
is rotated or skewed, or partially obscured.</p>

\@author Sean Owen
 */
var Detector = (function () {
    /**
     * @param {?} image
     */
    function Detector(image) {
        this.image = image;
    }
    /**
     * @return {?}
     */
    Detector.prototype.getImage = function () {
        return this.image;
    };
    /**
     * @return {?}
     */
    Detector.prototype.getResultPointCallback = function () {
        return this.resultPointCallback;
    };
    /**
     * <p>Detects a QR Code in an image.</p>
    
    \@param hints optional hints to detector
    \@return {\@link DetectorResult} encapsulating results of detecting a QR Code
    \@throws NotFoundException if QR Code cannot be found
    \@throws FormatException if a QR Code cannot be decoded
     * @param {?} hints
     * @return {?}
     */
    Detector.prototype.detect = function (hints) {
        this.resultPointCallback = (hints === null || hints === undefined) ? null :
            /*(ResultPointCallback) */ hints.get(9 /* NEED_RESULT_POINT_CALLBACK */);
        var /** @type {?} */ finder = new FinderPatternFinder(this.image, this.resultPointCallback);
        var /** @type {?} */ info = finder.find(hints);
        return this.processFinderPatternInfo(info);
    };
    /**
     * @param {?} info
     * @return {?}
     */
    Detector.prototype.processFinderPatternInfo = function (info) {
        var /** @type {?} */ topLeft = info.getTopLeft();
        var /** @type {?} */ topRight = info.getTopRight();
        var /** @type {?} */ bottomLeft = info.getBottomLeft();
        var /** @type {?} */ moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
        if (moduleSize < 1.0) {
            throw new Exception(Exception.NotFoundException);
        }
        var /** @type {?} */ dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
        var /** @type {?} */ provisionalVersion = Version.getProvisionalVersionForDimension(dimension);
        var /** @type {?} */ modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
        var /** @type {?} */ alignmentPattern = null;
        // Anything above version 1 has an alignment pattern
        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
            // Guess where a "bottom right" finder pattern would have been
            var /** @type {?} */ bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
            var /** @type {?} */ bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
            // Estimate that alignment pattern is closer by 3 modules
            // from "bottom right" to known top left location
            var /** @type {?} */ correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;
            var /** @type {?} */ estAlignmentX = Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
            var /** @type {?} */ estAlignmentY = Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));
            // Kind of arbitrary -- expand search radius before giving up
            for (var /** @type {?} */ i = 4; i <= 16; i <<= 1) {
                try {
                    alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
                    break;
                }
                catch (re /*NotFoundException*/) {
                    if (!Exception.isOfType(re, Exception.NotFoundException)) {
                        throw re;
                    }
                    // try next round
                }
            }
            // If we didn't find alignment pattern... well try anyway without it
        }
        var /** @type {?} */ transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
        var /** @type {?} */ bits = Detector.sampleGrid(this.image, transform, dimension);
        var /** @type {?} */ points;
        if (alignmentPattern === null) {
            points = [bottomLeft, topLeft, topRight];
        }
        else {
            points = [bottomLeft, topLeft, topRight, alignmentPattern];
        }
        return new DetectorResult(bits, points);
    };
    /**
     * @param {?} topLeft
     * @param {?} topRight
     * @param {?} bottomLeft
     * @param {?} alignmentPattern
     * @param {?} dimension
     * @return {?}
     */
    Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {
        var /** @type {?} */ dimMinusThree = dimension - 3.5;
        var /** @type {?} */ bottomRightX; /*float*/
        var /** @type {?} */ bottomRightY; /*float*/
        var /** @type {?} */ sourceBottomRightX; /*float*/
        var /** @type {?} */ sourceBottomRightY; /*float*/
        if (alignmentPattern !== null) {
            bottomRightX = alignmentPattern.getX();
            bottomRightY = alignmentPattern.getY();
            sourceBottomRightX = dimMinusThree - 3.0;
            sourceBottomRightY = sourceBottomRightX;
        }
        else {
            // Don't have an alignment pattern, just make up the bottom-right point
            bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();
            bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();
            sourceBottomRightX = dimMinusThree;
            sourceBottomRightY = dimMinusThree;
        }
        return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
    };
    /**
     * @param {?} image
     * @param {?} transform
     * @param {?} dimension
     * @return {?}
     */
    Detector.sampleGrid = function (image, transform, dimension /*int*/) {
        var /** @type {?} */ sampler = GridSamplerInstance.getInstance();
        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
    };
    /**
     * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
    of the finder patterns and estimated module size.</p>
     * @param {?} topLeft
     * @param {?} topRight
     * @param {?} bottomLeft
     * @param {?} moduleSize
     * @return {?}
     */
    Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize /*float*/) {
        var /** @type {?} */ tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
        var /** @type {?} */ tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
        var /** @type {?} */ dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
        switch (dimension & 0x03) {
            case 0:
                dimension++;
                break;
            // 1? do nothing
            case 2:
                dimension--;
                break;
            case 3:
                throw new Exception(Exception.NotFoundException);
        }
        return dimension;
    };
    /**
     * <p>Computes an average estimated module size based on estimated derived from the positions
    of the three finder patterns.</p>
    
    \@param topLeft detected top-left finder pattern center
    \@param topRight detected top-right finder pattern center
    \@param bottomLeft detected bottom-left finder pattern center
    \@return estimated module size
     * @param {?} topLeft
     * @param {?} topRight
     * @param {?} bottomLeft
     * @return {?}
     */
    Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {
        // Take the average
        return (this.calculateModuleSizeOneWay(topLeft, topRight) +
            this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;
    };
    /**
     * <p>Estimates module size based on two finder patterns -- it uses
    {\@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
    width of each, measuring along the axis between their centers.</p>
     * @param {?} pattern
     * @param {?} otherPattern
     * @return {?}
     */
    Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {
        var /** @type {?} */ moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), 
        /*(int) */ Math.floor(pattern.getY()), 
        /*(int) */ Math.floor(otherPattern.getX()), 
        /*(int) */ Math.floor(otherPattern.getY()));
        var /** @type {?} */ moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), 
        /*(int) */ Math.floor(otherPattern.getY()), 
        /*(int) */ Math.floor(pattern.getX()), 
        /*(int) */ Math.floor(pattern.getY()));
        if (isNaN(moduleSizeEst1)) {
            return moduleSizeEst2 / 7.0;
        }
        if (isNaN(moduleSizeEst2)) {
            return moduleSizeEst1 / 7.0;
        }
        // Average them, and divide by 7 since we've counted the width of 3 black modules,
        // and 1 white and 1 black module on either side. Ergo, divide sum by 14.
        return (moduleSizeEst1 + moduleSizeEst2) / 14.0;
    };
    /**
     * See {\@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
    a finder pattern by looking for a black-white-black run from the center in the direction
    of another point (another finder pattern center), and in the opposite direction too.
     * @param {?} fromX
     * @param {?} fromY
     * @param {?} toX
     * @param {?} toY
     * @return {?}
     */
    Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {
        var /** @type {?} */ result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
        // Now count other way -- don't run off image though of course
        var /** @type {?} */ scale = 1.0;
        var /** @type {?} */ otherToX = fromX - (toX - fromX);
        if (otherToX < 0) {
            scale = fromX / (fromX - otherToX);
            otherToX = 0;
        }
        else if (otherToX >= this.image.getWidth()) {
            scale = (this.image.getWidth() - 1 - fromX) / (otherToX - fromX);
            otherToX = this.image.getWidth() - 1;
        }
        var /** @type {?} */ otherToY = Math.floor(fromY - (toY - fromY) * scale);
        scale = 1.0;
        if (otherToY < 0) {
            scale = fromY / (fromY - otherToY);
            otherToY = 0;
        }
        else if (otherToY >= this.image.getHeight()) {
            scale = (this.image.getHeight() - 1 - fromY) / (otherToY - fromY);
            otherToY = this.image.getHeight() - 1;
        }
        otherToX = Math.floor(fromX + (otherToX - fromX) * scale);
        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
        // Middle pixel is double-counted this way; subtract 1
        return result - 1.0;
    };
    /**
     * <p>This method traces a line from a point in the image, in the direction towards another point.
    It begins in a black region, and keeps going until it finds white, then black, then white again.
    It reports the distance from the start to this point.</p>
    
    <p>This is used when figuring out how wide a finder pattern is, when the finder pattern
    may be skewed or rotated.</p>
     * @param {?} fromX
     * @param {?} fromY
     * @param {?} toX
     * @param {?} toY
     * @return {?}
     */
    Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {
        // Mild variant of Bresenham's algorithm
        // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
        var /** @type {?} */ steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
            var /** @type {?} */ temp = fromX;
            fromX = fromY;
            fromY = temp;
            temp = toX;
            toX = toY;
            toY = temp;
        }
        var /** @type {?} */ dx = Math.abs(toX - fromX);
        var /** @type {?} */ dy = Math.abs(toY - fromY);
        var /** @type {?} */ error = -dx / 2;
        var /** @type {?} */ xstep = fromX < toX ? 1 : -1;
        var /** @type {?} */ ystep = fromY < toY ? 1 : -1;
        // In black pixels, looking for white, first or second time.
        var /** @type {?} */ state = 0;
        // Loop up until x == toX, but not beyond
        var /** @type {?} */ xLimit = toX + xstep;
        for (var /** @type {?} */ x = fromX, /** @type {?} */ y = fromY; x != xLimit; x += xstep) {
            var /** @type {?} */ realX = steep ? y : x;
            var /** @type {?} */ realY = steep ? x : y;
            // Does current pixel mean we have moved white to black or vice versa?
            // Scanning black in state 0,2 and white in state 1, so if we find the wrong
            // color, advance to next state or end if we are in state 2 already
            if ((state === 1) === this.image.get(realX, realY)) {
                if (state === 2) {
                    return MathUtils.distance(x, y, fromX, fromY);
                }
                state++;
            }
            error += dy;
            if (error > 0) {
                if (y === toY) {
                    break;
                }
                y += ystep;
                error -= dx;
            }
        }
        // Found black-white-black; give the benefit of the doubt that the next pixel outside the image
        // is "white" so this last point at (toX+xStep,toY) is the right ending. This is really a
        // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.
        if (state === 2) {
            return MathUtils.distance(toX + xstep, toY, fromX, fromY);
        }
        // else we didn't find even black-white-black; no estimate is really possible
        return NaN;
    };
    /**
     * <p>Attempts to locate an alignment pattern in a limited region of the image, which is
    guessed to contain it. This method uses {\@link AlignmentPattern}.</p>
    
    \@param overallEstModuleSize estimated module size so far
    \@param estAlignmentX x coordinate of center of area probably containing alignment pattern
    \@param estAlignmentY y coordinate of above
    \@param allowanceFactor number of pixels in all directions to search from the center
    \@return {\@link AlignmentPattern} if found, or null otherwise
    \@throws NotFoundException if an unexpected error occurs during detection
     * @param {?} overallEstModuleSize
     * @param {?} estAlignmentX
     * @param {?} estAlignmentY
     * @param {?} allowanceFactor
     * @return {?}
     */
    Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {
        // Look for an alignment pattern (3 modules in size) around where it
        // should be
        var /** @type {?} */ allowance = Math.floor(allowanceFactor * overallEstModuleSize);
        var /** @type {?} */ alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
        var /** @type {?} */ alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
            throw new Exception(Exception.NotFoundException);
        }
        var /** @type {?} */ alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
        var /** @type {?} */ alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
            throw new Exception(Exception.NotFoundException);
        }
        var /** @type {?} */ alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
        return alignmentFinder.find();
    };
    return Detector;
}());

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This implementation can detect and decode QR Codes in an image.

\@author Sean Owen
 */
var QRCodeReader = (function () {
    function QRCodeReader() {
        this.decoder = new Decoder();
    }
    /**
     * @return {?}
     */
    QRCodeReader.prototype.getDecoder = function () {
        return this.decoder;
    };
    /**
     * @param {?} image
     * @param {?=} hints
     * @return {?}
     */
    QRCodeReader.prototype.decode = function (image, hints) {
        var /** @type {?} */ decoderResult;
        var /** @type {?} */ points;
        if (hints !== undefined && hints !== null && undefined !== hints.get(1 /* PURE_BARCODE */)) {
            var /** @type {?} */ bits = QRCodeReader.extractPureBits(image.getBlackMatrix());
            decoderResult = this.decoder.decodeBitMatrix(bits, hints);
            points = QRCodeReader.NO_POINTS;
        }
        else {
            var /** @type {?} */ detectorResult = new Detector(image.getBlackMatrix()).detect(hints);
            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
            points = detectorResult.getPoints();
        }
        // If the code was mirrored: swap the bottom-left and the top-right points.
        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
            ((decoderResult.getOther())).applyMirroredCorrection(points);
        }
        var /** @type {?} */ result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, 11 /* QR_CODE */, undefined);
        var /** @type {?} */ byteSegments = decoderResult.getByteSegments();
        if (byteSegments !== null) {
            result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);
        }
        var /** @type {?} */ ecLevel = decoderResult.getECLevel();
        if (ecLevel !== null) {
            result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        if (decoderResult.hasStructuredAppend()) {
            result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
            result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
        }
        return result;
    };
    /**
     * @return {?}
     */
    QRCodeReader.prototype.reset = function () {
        // do nothing
    };
    /**
     * This method detects a code in a "pure" image -- that is, pure monochrome image
    which contains only an unrotated, unskewed, image of a code, with some white border
    around it. This is a specialized method that works exceptionally fast in this special
    case.
    
    \@see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)
     * @param {?} image
     * @return {?}
     */
    QRCodeReader.extractPureBits = function (image) {
        var /** @type {?} */ leftTopBlack = image.getTopLeftOnBit();
        var /** @type {?} */ rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack === null || rightBottomBlack === null) {
            throw new Exception(Exception.NotFoundException);
        }
        var /** @type {?} */ moduleSize = this.moduleSize(leftTopBlack, image);
        var /** @type {?} */ top = leftTopBlack[1];
        var /** @type {?} */ bottom = rightBottomBlack[1];
        var /** @type {?} */ left = leftTopBlack[0];
        var /** @type {?} */ right = rightBottomBlack[0];
        // Sanity check!
        if (left >= right || top >= bottom) {
            throw new Exception(Exception.NotFoundException);
        }
        if (bottom - top !== right - left) {
            // Special case, where bottom-right module wasn't black so we found something else in the last row
            // Assume it's a square, so use height as the width
            right = left + (bottom - top);
            if (right >= image.getWidth()) {
                // Abort if that would not make sense -- off image
                throw new Exception(Exception.NotFoundException);
            }
        }
        var /** @type {?} */ matrixWidth = Math.round((right - left + 1) / moduleSize);
        var /** @type {?} */ matrixHeight = Math.round((bottom - top + 1) / moduleSize);
        if (matrixWidth <= 0 || matrixHeight <= 0) {
            throw new Exception(Exception.NotFoundException);
        }
        if (matrixHeight != matrixWidth) {
            // Only possibly decode square regions
            throw new Exception(Exception.NotFoundException);
        }
        // Push in the "border" by half the module width so that we start
        // sampling in the middle of the module. Just in case the image is a
        // little off, this will help recover.
        var /** @type {?} */ nudge = Math.floor(moduleSize / 2.0);
        top += nudge;
        left += nudge;
        // But careful that this does not sample off the edge
        // "right" is the farthest-right valid pixel location -- right+1 is not necessarily
        // This is positive by how much the inner x loop below would be too large
        var /** @type {?} */ nudgedTooFarRight = left + Math.floor((matrixWidth - 1) * moduleSize) - right;
        if (nudgedTooFarRight > 0) {
            if (nudgedTooFarRight > nudge) {
                // Neither way fits; abort
                throw new Exception(Exception.NotFoundException);
            }
            left -= nudgedTooFarRight;
        }
        // See logic above
        var /** @type {?} */ nudgedTooFarDown = top + Math.floor((matrixHeight - 1) * moduleSize) - bottom;
        if (nudgedTooFarDown > 0) {
            if (nudgedTooFarDown > nudge) {
                // Neither way fits; abort
                throw new Exception(Exception.NotFoundException);
            }
            top -= nudgedTooFarDown;
        }
        // Now just read off the bits
        var /** @type {?} */ bits = new BitMatrix(matrixWidth, matrixHeight);
        for (var /** @type {?} */ y = 0; y < matrixHeight; y++) {
            var /** @type {?} */ iOffset = top + Math.floor(y * moduleSize);
            for (var /** @type {?} */ x = 0; x < matrixWidth; x++) {
                if (image.get(left + Math.floor(x * moduleSize), iOffset)) {
                    bits.set(x, y);
                }
            }
        }
        return bits;
    };
    /**
     * @param {?} leftTopBlack
     * @param {?} image
     * @return {?}
     */
    QRCodeReader.moduleSize = function (leftTopBlack, image) {
        var /** @type {?} */ height = image.getHeight();
        var /** @type {?} */ width = image.getWidth();
        var /** @type {?} */ x = leftTopBlack[0];
        var /** @type {?} */ y = leftTopBlack[1];
        var /** @type {?} */ inBlack = true;
        var /** @type {?} */ transitions = 0;
        while (x < width && y < height) {
            if (inBlack !== image.get(x, y)) {
                if (++transitions === 5) {
                    break;
                }
                inBlack = !inBlack;
            }
            x++;
            y++;
        }
        if (x === width || y === height) {
            throw new Exception(Exception.NotFoundException);
        }
        return (x - leftTopBlack[0]) / 7.0;
    };
    return QRCodeReader;
}());
QRCodeReader.NO_POINTS = new Array();

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Based on Zxing-typescript BrowserCodeReader
 */
var BrowserCodeReaderExt = (function () {
    /**
     * @param {?} reader
     * @param {?=} timeBetweenScansMillis
     */
    function BrowserCodeReaderExt(reader, timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        this.reader = reader;
        this.timeBetweenScansMillis = timeBetweenScansMillis;
    }
    /**
     * @param {?} callbackFn
     * @param {?=} deviceId
     * @param {?=} videoElement
     * @return {?}
     */
    BrowserCodeReaderExt.prototype.decodeFromInputVideoDevice = function (callbackFn, deviceId, videoElement) {
        var _this = this;
        this.reset();
        this.prepareVideoElement(videoElement);
        var /** @type {?} */ constraints;
        if (undefined === deviceId) {
            constraints = {
                video: { facingMode: "environment" }
            };
        }
        else {
            constraints = {
                video: { deviceId: { exact: deviceId } }
            };
        }
        navigator.mediaDevices.getUserMedia(constraints)
            .then(function (stream) {
            _this.stream = stream;
            _this.videoElement.srcObject = stream;
            _this.videoPlayingEventListener = function () {
                _this.decodeWithDelay(callbackFn);
            };
            _this.videoElement.addEventListener("playing", _this.videoPlayingEventListener);
            _this.videoElement.play();
        });
    };
    /**
     * @param {?=} videoElement
     * @return {?}
     */
    BrowserCodeReaderExt.prototype.prepareVideoElement = function (videoElement) {
        if (undefined === videoElement) {
            this.videoElement = document.createElement("video");
            this.videoElement.width = 200;
            this.videoElement.height = 200;
        }
        else {
            this.videoElement = videoElement;
        }
    };
    /**
     * @param {?} callbackFn
     * @return {?}
     */
    BrowserCodeReaderExt.prototype.decodeWithDelay = function (callbackFn) {
        this.timeoutHandler = window.setTimeout(this.decode.bind(this, callbackFn), this.timeBetweenScansMillis);
    };
    /**
     * @param {?} callbackFn
     * @param {?=} retryIfNotFound
     * @param {?=} retryIfChecksumOrFormatError
     * @param {?=} once
     * @return {?}
     */
    BrowserCodeReaderExt.prototype.decode = function (callbackFn, retryIfNotFound, retryIfChecksumOrFormatError, once) {
        var _this = this;
        if (retryIfNotFound === void 0) { retryIfNotFound = true; }
        if (retryIfChecksumOrFormatError === void 0) { retryIfChecksumOrFormatError = true; }
        if (once === void 0) { once = false; }
        if (undefined === this.canvasElementContext) {
            this.prepareCaptureCanvas();
        }
        this.canvasElementContext.drawImage(this.videoElement || this.imageElement, 0, 0);
        var /** @type {?} */ luminanceSource = new HTMLCanvasElementLuminanceSource(this.canvasElement);
        var /** @type {?} */ binaryBitmap = new BinaryBitmap(new HybridBinarizer(luminanceSource));
        try {
            var /** @type {?} */ result = this.readerDecode(binaryBitmap);
            callbackFn(result);
            if (!once) {
                setTimeout(function () { return _this.decodeWithDelay(callbackFn); }, this.timeBetweenScansMillis);
            }
        }
        catch (re) {
            console.debug(retryIfChecksumOrFormatError, re);
            if (retryIfNotFound && Exception.isOfType(re, Exception.NotFoundException)) {
                console.debug("not found, trying again...");
                this.decodeWithDelay(callbackFn);
            }
            else if (retryIfChecksumOrFormatError && (Exception.isOfType(re, Exception.ChecksumException) || Exception.isOfType(re, Exception.FormatException))) {
                console.debug("checksum or format error, trying again...", re);
                this.decodeWithDelay(callbackFn);
            }
        }
    };
    /**
     * @param {?} binaryBitmap
     * @return {?}
     */
    BrowserCodeReaderExt.prototype.readerDecode = function (binaryBitmap) {
        return this.reader.decode(binaryBitmap);
    };
    /**
     * @return {?}
     */
    BrowserCodeReaderExt.prototype.prepareCaptureCanvas = function () {
        var /** @type {?} */ canvasElement = document.createElement("canvas");
        var /** @type {?} */ width, /** @type {?} */ height;
        if (undefined !== this.videoElement) {
            width = this.videoElement.videoWidth;
            height = this.videoElement.videoHeight;
        }
        else {
            width = this.imageElement.naturalWidth || this.imageElement.width;
            height = this.imageElement.naturalHeight || this.imageElement.height;
        }
        canvasElement.style.width = width + "px";
        canvasElement.style.height = height + "px";
        canvasElement.width = width;
        canvasElement.height = height;
        this.canvasElement = canvasElement;
        this.canvasElementContext = canvasElement.getContext("2d");
    };
    /**
     * @return {?}
     */
    BrowserCodeReaderExt.prototype.stop = function () {
        if (undefined !== this.timeoutHandler) {
            window.clearTimeout(this.timeoutHandler);
            this.timeoutHandler = undefined;
        }
        if (undefined !== this.stream) {
            this.stream.getTracks()[0].stop();
            this.stream = undefined;
        }
    };
    /**
     * @return {?}
     */
    BrowserCodeReaderExt.prototype.reset = function () {
        this.stop();
        if (undefined !== this.videoPlayEndedEventListener && undefined !== this.videoElement) {
            this.videoElement.removeEventListener("ended", this.videoPlayEndedEventListener);
        }
        if (undefined !== this.videoPlayingEventListener && undefined !== this.videoElement) {
            this.videoElement.removeEventListener("playing", this.videoPlayingEventListener);
        }
        if (undefined !== this.videoElement) {
            this.videoElement.srcObject = undefined;
            this.videoElement.removeAttribute("src");
            this.videoElement = undefined;
        }
        if (undefined !== this.videoPlayEndedEventListener && undefined !== this.imageElement) {
            this.imageElement.removeEventListener("load", this.imageLoadedEventListener);
        }
        if (undefined !== this.imageElement) {
            this.imageElement.src = undefined;
            this.imageElement.removeAttribute("src");
            this.imageElement = undefined;
        }
        this.canvasElementContext = undefined;
        this.canvasElement = undefined;
    };
    return BrowserCodeReaderExt;
}());
var BrowserQRCodeReaderExt = (function (_super) {
    __extends(BrowserQRCodeReaderExt, _super);
    /**
     * @param {?=} timeBetweenScansMillis
     */
    function BrowserQRCodeReaderExt(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        return _super.call(this, new QRCodeReader(), timeBetweenScansMillis) || this;
    }
    return BrowserQRCodeReaderExt;
}(BrowserCodeReaderExt));

var NgxZxingComponent = (function () {
    function NgxZxingComponent() {
        this.destroyed$ = new Subject$1();
        this.codeReader = new BrowserQRCodeReaderExt(1500);
        this.start = false;
        this.onScan = new EventEmitter();
        this.onCamsFound = new EventEmitter();
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
            navigator.enumerateDevices = function (callback) {
                navigator.mediaDevices.enumerateDevices().then(callback);
            };
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxZxingComponent.prototype.ngOnChanges = function (changes) {
        if (changes.start) {
            if (this.start) {
                this.startCam();
            }
            else {
                this.stopCam();
            }
        }
        if (changes.device && this.device) {
            this.stopCam();
            this.deviceId = this.device.deviceId;
            if (this.start) {
                this.startCam();
            }
        }
    };
    /**
     * @return {?}
     */
    NgxZxingComponent.prototype.ngAfterViewInit = function () {
        // iOS 11 Fix
        this.previewElem.nativeElement.setAttribute("autoplay", true);
        this.previewElem.nativeElement.setAttribute("muted", true);
        this.previewElem.nativeElement.setAttribute("playsinline", true);
        this.previewElem.nativeElement.setAttribute("autofocus", true);
        this.enumerateCams();
        if (this.start) {
            this.startCam();
        }
    };
    /**
     * @return {?}
     */
    NgxZxingComponent.prototype.ngOnDestroy = function () {
        this.destroyed$.next();
        this.destroyed$.complete();
    };
    /**
     * @return {?}
     */
    NgxZxingComponent.prototype.enumerateCams = function () {
        var _this = this;
        navigator.mediaDevices.getUserMedia({ audio: false, video: true }).then(function (stream) {
            _this.getAllAudioVideoDevices(function (videoInputDevices) {
                if (videoInputDevices && videoInputDevices.length > 0) {
                    _this.onCamsFound.next(videoInputDevices);
                    _this.deviceId = videoInputDevices[0].deviceId;
                }
            });
            // Start stream so Browser can display permission-dialog ("Website wants to access your camera, allow?")
            _this.previewElem.nativeElement.srcObject = stream;
            // After permission was granted, we can stop it again
            stream.getVideoTracks().forEach(function (track) {
                track.stop();
            });
            stream.getAudioTracks().forEach(function (track) {
                track.stop();
            });
        }).catch(function (error) {
            console.error(error);
        });
    };
    /**
     * @return {?}
     */
    NgxZxingComponent.prototype.startCam = function () {
        this.scan(this.deviceId);
    };
    /**
     * @param {?} deviceId
     * @return {?}
     */
    NgxZxingComponent.prototype.scan = function (deviceId) {
        var _this = this;
        this.codeReader.decodeFromInputVideoDevice(function (result) {
            console.debug("ngx-zxing:", "result from scan:", result);
            _this.scanSuccess(result);
        }, deviceId, this.previewElem.nativeElement);
    };
    /**
     * @return {?}
     */
    NgxZxingComponent.prototype.stopCam = function () {
        this.codeReader.reset();
    };
    /**
     * @param {?} result
     * @return {?}
     */
    NgxZxingComponent.prototype.scanSuccess = function (result) {
        this.onScan.next(result.text);
    };
    /**
     * @param {?} successCallback
     * @return {?}
     */
    NgxZxingComponent.prototype.getAllAudioVideoDevices = function (successCallback) {
        if (!((navigator)).enumerateDevices) {
            console.error("Can't enumerate Devices");
            return;
        }
        var /** @type {?} */ videoInputDevices = [];
        ((navigator)).enumerateDevices(function (devices) {
            for (var /** @type {?} */ i = 0, /** @type {?} */ len = devices.length; i < len; i++) {
                var /** @type {?} */ device = {};
                for (var /** @type {?} */ d in devices[i]) {
                    device[d] = devices[i][d];
                }
                if (device.kind === "video") {
                    device.kind = "videoinput";
                }
                if (!device.deviceId) {
                    device.deviceId = device.id;
                }
                if (!device.id) {
                    device.id = device.deviceId;
                }
                if (!device.label) {
                    device.label = "Camera (No Permission)";
                }
                if (device.kind === "videoinput" || device.kind === "video") {
                    videoInputDevices.push(device);
                }
            }
            successCallback(videoInputDevices);
        });
    };
    return NgxZxingComponent;
}());
NgxZxingComponent.decorators = [
    { type: Component, args: [{
                selector: "ngx-zxing",
                template: "\n        <div class=\"form\">\n            <video id=\"preview\" #preview style="height: 200px;"></video>\n        </div>"
            },] },
];
/**
 * @nocollapse
 */
NgxZxingComponent.ctorParameters = function () { return []; };
NgxZxingComponent.propDecorators = {
    'previewElem': [{ type: ViewChild, args: ["preview",] },],
    'start': [{ type: Input },],
    'device': [{ type: Input },],
    'onScan': [{ type: Output },],
    'onCamsFound': [{ type: Output },],
};

var NgxZxingModule = (function () {
    function NgxZxingModule() {
    }
    /**
     * @return {?}
     */
    NgxZxingModule.forRoot = function () {
        return {
            ngModule: NgxZxingModule
        };
    };
    return NgxZxingModule;
}());
NgxZxingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    NgxZxingComponent,
                ],
                exports: [
                    NgxZxingComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
NgxZxingModule.ctorParameters = function () { return []; };

export { NgxZxingModule, NgxZxingComponent };
